<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[js获取对象的属性]]></title>
      <url>%2F2018%2F06%2F29%2Fjs%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[for...in#该方法一次访问一个对象及其原型链中所有可枚举的属性1234let obj = &#123;name:'june', age:'forever 18'&#125;for (let i in obj)&#123; console.log(i)&#125; Object.keys()#返回指定对象属性名的数组，顺序和常规循环获得的一样。1234567const obj = &#123; name: 'june', age: '18', gender: 'female'&#125;console.log(Object.keys(obj));//运行结果:["name", "age", "gender"] 该方法返回的是对象自己的可枚举的属性。 Object.keys() returns an array whose elements are strings corresponding to the enumerable properties found directly upon object. The ordering of the properties is the same as that given by looping over the properties of the object manually. 引用自mdn。如果想要对象的所有属性，包括不可枚举的属性，使用 Object.getOwnPropertyNames() 。 注意：在es5中，如果传入这个方法的参数不是对象，比如一个原始类型，会引发TypeError错误。但在es6，非对象的参数会被强制转化为一个对象。1234Object.keys('june');// TypeError: 'june' is not an object (ES5 code)Object.keys('june');//["0", "1", "2", "3"] 兼容代码：1234567891011121314151617181920212223242526272829303132333435363738394041// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keysif (!Object.keys) &#123; Object.keys = (function() &#123; 'use strict'; var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !(&#123; toString: null &#125;).propertyIsEnumerable('toString'), dontEnums = [ 'toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor' ], dontEnumsLength = dontEnums.length; return function(obj) &#123; if (typeof obj !== 'function' &amp;&amp; (typeof obj !== 'object' || obj === null)) &#123; throw new TypeError('Object.keys called on non-object'); &#125; var result = [], prop, i; for (prop in obj) &#123; if (hasOwnProperty.call(obj, prop)) &#123; result.push(prop); &#125; &#125; if (hasDontEnumBug) &#123; for (i = 0; i &lt; dontEnumsLength; i++) &#123; if (hasOwnProperty.call(obj, dontEnums[i])) &#123; result.push(dontEnums[i]); &#125; &#125; &#125; return result; &#125;; &#125;());&#125; Object.getOwnPropertyNames()#返回一个数组，数组的元素为对象自身属性名称的字符串，包括可枚举和不可枚举的属性，但不包括Symbol值作为名称的属性。可枚举属性在数组中的顺序与 for...in 或者 Object.keys() 一致。但不可枚举的属性顺序未定义。12345678910111213141516171819202122232425let arr = ["June", "Lucy", "Sheery", "Alina"];console.log(Object.getOwnPropertyNames(arr).sort());// 运行结果：["0", "1", "2", "3", "length"]// 类数组对象let girls = &#123; 0: "June", 1: "Lucy", 2: "Sheery", 3:"Alina"&#125;;console.log(Object.getOwnPropertyNames(girls).sort());// 运行结果：["0", "1", "2", "3"]// 用Array.forEach输出属性名和属性值Object.getOwnPropertyNames(girls).forEach(function(val, idx, array) &#123; console.log(val + " -&gt; " + girls[val]);&#125;);// 不可枚举属性let june = Object.create(&#123;&#125;, &#123; get_skills: &#123; value: function() &#123; return this.skills; &#125;, enumerable: false &#125;&#125;);june.skills=["HTML", "CSS", "JavaSript", "Python", "Sql"];console.log(Object.getOwnPropertyNames(june).sort()); //运行结果：["get_skills", "skills"] 总结：如果只需要获取可枚举属性，用Object.keys()或者for...in循环，这样还会获取原型链上的可枚举属性，不过可以使用hasOwnProperty()方法过滤掉。或使用Object.getOwnPropertyNames()获得所有属性，再用Array.prototype.fiter()方法过滤。提示：Object.getOwnPropertyNames()在ES5中如果参数不是原始对象类型，将抛出TypeError异常，ES6中，非对象参数会被强制转为对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax复习]]></title>
      <url>%2F2018%2F06%2F29%2Fajax%E5%A4%8D%E4%B9%A0-1%2F</url>
      <content type="text"><![CDATA[面试被问到一个关于ajax的优缺点问题，引出了HTML5的history。趁这个机会总结复习一下AJAX的知识点。Ajax,是Asynchronous Javascript and XML的缩写，用来描述基于用脚本操纵HTTP请求的Web应用架构。Ajax应用的主要特点是使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载。 一个HTTP请求由四个部分组成： HTTP请求方法或‘动作’ 正在请求的URL 一个可选的请求头集合，其中可能包含身份验证信息 一个可选的请求主体 服务器返回的HTTP响应包含三部分： 一个数字和文字组成的状态码，用来显示请求的成功和失败 一个响应头集合 响应主体 CORS#XHR2通过HTTP响应中选择发送合适对CORS(Cross-Origin Resource Sharing跨域资源共享)允许跨域访问网站。 ajax优点# 无刷新更新数据 异步服务器通信 前后端负载平和 界面与应用分离 ajax缺点# 破坏浏览器机制 安全问题 对搜索引擎支持较弱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6-cheatsheet]]></title>
      <url>%2F2018%2F06%2F15%2Fes6-cheatsheet%2F</url>
      <content type="text"><![CDATA[这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你完成日复一日的开发工作。 Table of Contents# var 与 let / const 声明 代码执行块替换立即执行函数 箭头函数 字符串 解构 模块 参数 类 Symbols Maps WeakMaps Promises Generators Async Await var versus let / const# 除了 var 以外，我们现在多了两个新的标识符来声明变量的存储，它们就是 let 和 const。不同于 var ，let 和 const 语句不会造成声明提升。 一个 var 的例子: 1234567891011var snack = 'Meow Mix';function getFood(food) &#123; if (food) &#123; var snack = 'Friskies'; return snack; &#125; return snack;&#125;getFood(false); // undefined 让我们再观察下面语句中，使用 let 替换了 var 后的表现： 1234567891011let snack = 'Meow Mix';function getFood(food) &#123; if (food) &#123; let snack = 'Friskies'; return snack; &#125; return snack;&#125;getFood(false); // 'Meow Mix' 当我们重构使用 var 的老代码时，一定要注意这种变化。盲目使用 let 替换 var 后可能会导致预期意外的结果。 注意：let 和 const 是块级作用域语句。所以在语句块以外引用这些变量时，会造成引用错误 ReferenceError。 123console.log(x);let x = 'hi'; // ReferenceError: x is not defined 最佳实践: 在重构老代码时，var 声明需要格外的注意。在创建一个新项目时，使用 let 声明一个变量，使用 const 来声明一个不可改变的常量。 (回到目录) Replacing IIFEs with Blocks#我们以往创建一个 立即执行函数 时，一般是在函数最外层包裹一层括号。ES6支持块级作用域（更贴近其他语言），我们现在可以通过创建一个代码块（Block）来实现，不必通过创建一个函数来实现， 12345(function () &#123; var food = 'Meow Mix';&#125;());console.log(food); // Reference Error 使用支持块级作用域的ES6的版本： 12345&#123; let food = 'Meow Mix';&#125;console.log(food); // Reference Error (回到目录) Arrow Functions#一些时候，我们在函数嵌套中需要访问上下文中的 this。比如下面的例子： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; // Cannot read property 'name' of undefined &#125;);&#125;; 一种通用的方式是把上下文中的 this 保存在一个变量里： 12345678910function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; var that = this; // Store the context of this return arr.map(function (character) &#123; return that.name + character; &#125;);&#125;; 我们也可以把 this 通过属性传进去： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; &#125;, this);&#125;; 还可以直接使用 bind： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character; &#125;.bind(this));&#125;; 使用 箭头函数，this 的值不用我们再做如上几段代码的特殊处理，直接使用即可。上面的代码可以重写为下面这样： 1234567function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(character =&gt; this.name + character);&#125;; 最佳实践：使用箭头函数，再也不用考虑 this 的问题了。 当我们编写只返回一个表达式值的简单函数时，也可以使用箭头函数，如下： 1var squares = arr.map(function (x) &#123; return x * x &#125;); // Function Expression 12const arr = [1, 2, 3, 4, 5];const squares = arr.map(x =&gt; x * x); // Arrow Function for terser implementation 最佳实践：尽可能地多使用 箭头函数。 (回到目录) Strings#在ES6中，标准库也被同样增强了，像字符串对象就新增了 .includes() 和 .repeat() 方法。 .includes( )#1234var string = 'food';var substring = 'foo';console.log(string.indexOf(substring) &gt; -1); 现在，我们可以使用 .inclues() 方法，替代以往判断内容 &gt; -1 的方式。.includes() 方法会极简地返回一个布尔值结果。 1234const string = 'food';const substring = 'foo';console.log(string.includes(substring)); // true .repeat( )#1234567function repeat(string, count) &#123; var strings = []; while(strings.length &lt; count) &#123; strings.push(string); &#125; return strings.join('');&#125; 在ES6中，我们可以使用一个极简的方法来实现重复字符： 12// String.repeat(numberOfRepetitions)'meow'.repeat(3); // 'meowmeowmeow' Template Literals#使用 字符串模板字面量，我可以在字符串中直接使用特殊字符，而不用转义。 1var text = "This string contains \"double quotes\" which are escaped."; 1let text = `This string contains "double quotes" which don't need to be escaped anymore.`; 字符串模板字面量 还支持直接插入变量，可以实现字符串与变量的直接连接输出。 1234var name = 'Tiger';var age = 13;console.log('My cat is named ' + name + ' and is ' + age + ' years old.'); 更简单的版本： 1234const name = 'Tiger';const age = 13;console.log(`My cat is named $&#123;name&#125; and is $&#123;age&#125; years old.`); ES5中，我们要这样生成多行文本： 12345var text = ( 'cat\n' + 'dog\n' + 'nickelodeon'); 或者： 12345var text = [ 'cat', 'dog', 'nickelodeon'].join('\n'); 字符串模板字面量 让我们不必特别关注多行字符串中的换行转义符号，直接换行即可： 1234let text = ( `catdognickelodeon`); 字符串模板字面量 内部可以使用表达式，像这样： 12let today = new Date();let text = `The time and date is $&#123;today.toLocaleString()&#125;`; (回到目录) Destructuring#解构让我们可以使用非常便捷的语法，直接将数组或者对象中的值直接分别导出到多个变量中， Destructuring Arrays#解构数组 12345var arr = [1, 2, 3, 4];var a = arr[0];var b = arr[1];var c = arr[2];var d = arr[3]; 1234let [a, b, c, d] = [1, 2, 3, 4];console.log(a); // 1console.log(b); // 2 Destructuring Objects#解构对象 123var luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;var occupation = luke.occupation; // 'jedi'var father = luke.father; // 'anakin' 12345let luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;let &#123;occupation, father&#125; = luke;console.log(occupation); // 'jedi'console.log(father); // 'anakin' (回到目录) Modules#ES6之前，浏览器端的模块化代码，我们使用像Browserify这样的库，在 Node.js 中，我们则使用 require。在ES6中，我们现在可以直接使用AMD 和 CommonJS这些模块了。 Exporting in CommonJS#1234module.exports = 1;module.exports = &#123; foo: 'bar' &#125;;module.exports = ['foo', 'bar'];module.exports = function bar () &#123;&#125;; Exporting in ES6#在ES6中，提供了多种设置模块出口的方式，比如我们要导出一个变量，那么使用 变量名 ： 12export let name = 'David';export let age = 25;​​ 还可以为对象 导出一个列表： 123456789function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;export &#123; sumTwo, sumThree &#125;; 我们也可以使用简单的一个 export 关键字来导出一个结果值： 1234567export function sumTwo(a, b) &#123; return a + b;&#125;export function sumThree(a, b, c) &#123; return a + b + c;&#125; 最后，我们可以 导出一个默认出口： 1234567891011121314function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;let api = &#123; sumTwo, sumThree&#125;;export default api; 最佳实践：总是在模块的 最后 使用 export default 方法。它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。更多的是，在大量CommonJS模块中，通用的习惯是设置一个出口值或者出口对象。接受这个规则，可以让我们的代码更易读，且更方便的联合使用CommonJS和ES6模块。 Importing in ES6#ES6提供了好几种模块的导入方式。我们可以单独引入一个文件： 1import 'underscore'; 这里需要注意的是， 整个文件的引入方式会执行该文件内的最上层代码。 就像Python一样，我们还可以命名引用： 1import &#123; sumTwo, sumThree &#125; from 'math/addition'; 我们甚至可以使用 as 给这些模块重命名： 1234import &#123; sumTwo as addTwoNumbers, sumThree as sumThreeNumbers&#125; from 'math/addition'; 另外，我们能 引入所有的东西（原文：import all the things） （也称为命名空间引入） 1import * as util from 'math/addition'; 最后，我们可以从一个模块的众多值中引入一个列表： 12import * as additionUtil from 'math/addtion';const &#123; sumTwo, sumThree &#125; = additionUtil; 像这样引用默认对象： 12import api from 'math/addition';// Same as: import &#123; default as api &#125; from 'math/addition'; 我们建议一个模块导出的值应该越简洁越好，不过有时候有必要的话命名引用和默认引用可以混着用。如果一个模块是这样导出的： 12// foos.jsexport &#123; foo as default, foo1, foo2 &#125;; 那我们可以如此导入这个模块的值： 1import foo, &#123; foo1, foo2 &#125; from &apos;foos&apos;; 我们还可以导入commonjs模块，例如React： 12import React from 'react';const &#123; Component, PropTypes &#125; = React; 更简化版本： 1import React, &#123; Component, PropTypes &#125; from 'react'; 注意：被导出的值是被 绑定的（原文：bingdings），而不是引用。所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。 (回到目录) Parameters#在ES5中，许多种方法来处理函数的 参数默认值（default values），参数数量（indefinite arguments），参数命名（named parameters）。ES6中，我们可以使用非常简洁的语法来处理上面提到的集中情况。 Default Parameters#12345function addTwoNumbers(x, y) &#123; x = x || 0; y = y || 0; return x + y;&#125; ES6中，我们可以简单为函数参数启用默认值： 123function addTwoNumbers(x=0, y=0) &#123; return x + y;&#125; 123addTwoNumbers(2, 4); // 6addTwoNumbers(2); // 2addTwoNumbers(); // 0 Rest Parameters#ES5中，遇到参数数量不确定时，我们只能如此处理： 12345function logArguments() &#123; for (var i=0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125; 使用 rest 操作符，我们可以给函数传入一个不确定数量的参数列表： 12345function logArguments(...args) &#123; for (let arg of args) &#123; console.log(arg); &#125;&#125; Named Parameters#命名函数ES5中，当我们要处理多个 命名参数 时，通常会传入一个 选项对象 的方式，这种方式被jQuery采用。 12345function initializeCanvas(options) &#123; var height = options.height || 600; var width = options.width || 400; var lineStroke = options.lineStroke || 'black';&#125; 我们可以利用上面提到的新特性 解构 ，来完成与上面同样功能的函数：12345function initializeCanvas( &#123; height=600, width=400, lineStroke='black'&#125;) &#123; // ... &#125; // Use variables height, width, lineStroke here 如果我们需要把这个参数变为可选的，那么只要把该参数解构为一个空对象就好了： 1234function initializeCanvas( &#123; height=600, width=400, lineStroke='black'&#125; = &#123;&#125;) &#123; // ... &#125; Spread Operator#我们可以利用展开操作符（Spread Operator）来把一组数组的值，当作参数传入： 1Math.max(...[-1, 100, 9001, -32]); // 9001 (回到目录) Classes#在ES6以前，我们实现一个类的功能的话，需要首先创建一个构造函数，然后扩展这个函数的原型方法，就像这样： 123456789function Person(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.incrementAge = function () &#123; return this.age += 1;&#125;; 继承父类的子类需要这样： 1234567891011function Personal(name, age, gender, occupation, hobby) &#123; Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby;&#125;Personal.prototype = Object.create(Person.prototype);Personal.prototype.constructor = Personal;Personal.prototype.incrementAge = function () &#123; return Person.prototype.incrementAge.call(this) += 20;&#125;; ES6提供了一些语法糖来实现上面的功能，我们可以直接创建一个类： 1234567891011class Person &#123; constructor(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; incrementAge() &#123; this.age += 1; &#125;&#125; 继承父类的子类只要简单的使用 extends 关键字就可以了： 12345678910111213class Personal extends Person &#123; constructor(name, age, gender, occupation, hobby) &#123; super(name, age, gender); this.occupation = occupation; this.hobby = hobby; &#125; incrementAge() &#123; super.incrementAge(); this.age += 20; console.log(this.age); &#125;&#125; 最佳实践：ES6新的类语法把我们从晦涩难懂的实现和原型操作中解救出来，这是个非常适合初学者的功能，而且能让我们写出更干净整洁的代码。 (回到目录) Symbols#符号（Symbols）在ES6版本之前就已经存在了，但现在我们拥有一个公共的接口来直接使用它们。Symbols对象是一旦创建就不可以被更改的（immutable）而且能被用做hash数据类型中的键。 Symbol( )#调用 Symbol() 或者 Symbol(描述文本) 会创建一个唯一的、在全局中不可以访问的符号对象。一个 Symbol() 的应用场景是：在自己的项目中使用第三方代码库，且你需要给他们的对象或者命名空间打补丁代码，又不想改动或升级第三方原有代码的时候。举个例子，如果你想给 React.Component 这个类添加一个 refreshComponent 方法，但又确定不了这个方法会不会在下个版本中加入，你可以这么做： 12345const refreshComponent = Symbol();React.Component.prototype[refreshComponent] = () =&gt; &#123; // do something&#125; Symbol.for(key)#使用 Symbol.for(key) 也是会创建一个不可改变的Symbol对象，但区别于上面的创建方法，这个对象是在全局中可以被访问到的。调用两次 Symbol.for(key) 会返回相同的Symbol实例。 提示：这并不同于 Symbol(description)。 123Symbol('foo') === Symbol('foo') // falseSymbol.for('foo') === Symbol('foo') // falseSymbol.for('foo') === Symbol.for('foo') // true 一个Symbols常用的使用场景，是需要使用特别 Symbol.for(key) 方法来实现代码间的协作。这能让你在你的代码中，查找包含已知的接口的第三方代码中Symbol成员。（译者：这句话好难翻。。。原文：This can beachieved by having your code look for a Symbol member on object arguments from third parties that contain some known interface. ）举个例子： 123456789function reader(obj) &#123; const specialRead = Symbol.for('specialRead'); if (obj[specialRead]) &#123; const reader = obj[specialRead](); // do something with reader &#125; else &#123; throw new TypeError('object cannot be read'); &#125;&#125; 之后在另一个库中： 12345678const specialRead = Symbol.for('specialRead');class SomeReadableType &#123; [specialRead]() &#123; const reader = createSomeReaderFrom(this); return reader; &#125;&#125; 注意：Symbol.iterable 在ES6中像其他可枚举的对象，如数组，字符串，generators一样，当这个方法被调用时会激活一个枚举器并返回一个对象。 (回到目录) Maps#Maps 是一个Javascript中很重要（迫切需要）的数据结构。在ES6之前，我们创建一个 hash 通常是使用一个对象： 123var map = new Object();map[key1] = 'value1';map[key2] = 'value2'; 但是，这样的代码无法避免函数被特别的属性名覆盖的意外情况： 12&gt; getOwnProperty(&#123; hasOwnProperty: 'Hah, overwritten'&#125;, 'Pwned');&gt; TypeError: Property 'hasOwnProperty' is not a function Maps 让我们使用 set，get 和 search 操作数据。 1234let map = new Map();&gt; map.set('name', 'david');&gt; map.get('name'); // david&gt; map.has('name'); // true Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。 123456789101112let map = new Map([ ['name', 'david'], [true, 'false'], [1, 'one'], [&#123;&#125;, 'object'], [function () &#123;&#125;, 'function']]);for (let key of map.keys()) &#123; console.log(typeof key); // &gt; string, boolean, number, object, function&#125; 提示：当使用 map.get() 判断值是否相等时，非基础类型比如一个函数或者对象，将不会正常工作。有鉴于此，还是建议使用字符串，布尔和数字类型的数据类型。 我们还可以使用 .entries() 方法来遍历整个map对象： 123for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125; (回到目录) WeakMaps#在ES5之前的版本，我们为了存储私有数据，有好几种方法。像使用这种下划线命名约定： 123456789class Person &#123; constructor(age) &#123; this._age = age; &#125; _incrementAge() &#123; this._age += 1; &#125;&#125; 在一个开源项目中，命名规则很难维持得一直很好，这样经常会造成一些困扰。此时，我们可以选择使用WeakMaps来替代Maps来存储我们的数据： 1234567891011121314let _age = new WeakMap();class Person &#123; constructor(age) &#123; _age.set(this, age); &#125; incrementAge() &#123; let age = _age.get(this) + 1; _age.set(this, age); if (age &gt; 50) &#123; console.log('Midlife crisis'); &#125; &#125;&#125; 使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名，就像下面的例子中的 Reflect.ownKeys()： 123&gt; const person = new Person(50);&gt; person.incrementAge(); // 'Midlife crisis'&gt; Reflect.ownKeys(person); // [] 一个使用WeakMaps存储数据更实际的例子，就是有关于一个DOM元素和对该DOM元素（有污染）地操作： 1234567891011121314let map = new WeakMap();let el = document.getElementById('someElement');// Store a weak reference to the element with a keymap.set(el, 'reference');// Access the value of the elementlet value = map.get(el); // 'reference'// Remove the referenceel.parentNode.removeChild(el);el = null;value = map.get(el); // undefined 上面的例子中，一个对象被垃圾回收期给销毁了，WeakMaps会自动的把自己内部所对应的键值对数据同时销毁。 提示：结合这个例子，再考虑下jQuery是如何实现缓存带有引用的DOM元素这个功能的，使用了WeakMaps的话，当被缓存的DOM元素被移除的时，jQuery可以自动释放相应元素的内存。通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常适合的。 (回到目录) Promises#Promises让我们让我们多缩进难看的代码（回调地狱）： 1234567891011func1(function (value1) &#123; func2(value1, function (value2) &#123; func3(value2, function (value3) &#123; func4(value3, function (value4) &#123; func5(value4, function (value5) &#123; // Do something with value 5 &#125;); &#125;); &#125;); &#125;);&#125;); 写成这样： 1234567func1(value1) .then(func2) .then(func3) .then(func4) .then(func5, value5 =&gt; &#123; // Do something with value 5 &#125;); 在ES6之前，我们使用bluebird 或者q。现在我们有了原生版本的 Promises： 123new Promise((resolve, reject) =&gt; reject(new Error('Failed to fulfill Promise'))) .catch(reason =&gt; console.log(reason)); 这里有两个处理函数，resolve（当Promise执行成功完毕时调用的回调函数） 和 reject （当Promise执行不接受时调用的回调函数） Promises的好处：大量嵌套错误回调函数会使代码变得难以阅读理解。使用了Promises，我们可以让我们代码变得更易读，组织起来更合理。此外，Promise处理后的值，无论是解决还是拒绝的结果值，都是不可改变的。 下面是一些使用Promises的实际例子： 1234567var fetchJSON = function(url) &#123; return new Promise((resolve, reject) =&gt; &#123; $.getJSON(url) .done((json) =&gt; resolve(json)) .fail((xhr, status, err) =&gt; reject(status + err.message)); &#125;);&#125;; 我们还可以使用 Promise.all() 来异步的 并行 处理一个数组的数据。 123456789101112131415var urls = [ 'http://www.api.com/items/1234', 'http://www.api.com/items/4567'];var urlPromises = urls.map(fetchJSON);Promise.all(urlPromises) .then(function (results) &#123; results.forEach(function (data) &#123; &#125;); &#125;) .catch(function (err) &#123; console.log('Failed: ', err); &#125;); (回到目录) Generators#就像Promises如何让我们避免回调地狱一样，Generators也可以使我们的代码扁平化，同时给予我们开发者像开发同步代码一样的感觉来写异步代码。Generators本质上是一种支持的函数，随后返回表达式的值。Generators实际上是支持暂停运行，随后根据上一步的返回值再继续运行的一种函数。 下面代码是一个使用generators函数的简单例子： 123456789101112function* sillyGenerator() &#123; yield 1; yield 2; yield 3; yield 4;&#125;var generator = sillyGenerator();&gt; console.log(generator.next()); // &#123; value: 1, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 2, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 3, done: false &#125;&gt; console.log(generator.next()); // &#123; value: 4, done: false &#125; 就像上面的例子，当next运行时，它会把我们的generator向前“推动”，同时执行新的表达式。我们能利用Generators来像书写同步代码一样书写异步代码。 1234567// Hiding asynchronousity with Generatorsfunction request(url) &#123; getJSON(url, function(response) &#123; generator.next(response); &#125;);&#125; 这里我们写个generator函数将要返回我们的数据： 123456function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125; 借助于 yield，我们可以保证 entry1 确实拿到数据并转换后再赋值给 data1。 当我们使用generators来像书写同步代码一样书写我们的异步代码逻辑时，没有一种清晰简单的方式来处理期间可能会产生的错误或者异常。在这种情况下，我们可以在我们的generator中引入Promises来处理，就像下面这样： 12345function request(url) &#123; return new Promise((resolve, reject) =&gt; &#123; getJSON(url, resolve); &#125;);&#125; 我们再写一个函数，其中使用 next 来步进我们的generator的同时，再利用我们上面的 request 方法来产生（yield）一个Promise。 12345678910function iterateGenerator(gen) &#123; var generator = gen(); var ret; (function iterate(val) &#123; ret = generator.next(); if(!ret.done) &#123; ret.value.then(iterate); &#125; &#125;)();&#125; 在Generator中引入了Promises后，我们就可以通过Promise的 .catch 和 reject 来捕捉和处理错误了。使用了我们新版的Generator后，新版的调用就像老版本一样简单可读（译者注：有微调）： 123456iterateGenerator(function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125;); 在使用Generator后，我们可以重用我们的老版本代码实现，以此展示了Generator的力量。当使用Generators和Promises后，我们可以像书写同步代码一样书写异步代码的同时优雅地解决了错误处理问题。此后，我们实际上可以开始利用更简单的一种方式了，它就是async-await。 (回到目录) Async Await#async await 随着ES2016版本就要发布了，它给我们提供了一种更轻松的、更简单的可以替代的实现上面 Generators 配合 Promises 组合代码的一种编码方式，让我们来看看例子： 12345678910111213141516var request = require('request');function getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; request(url, function(error, response, body) &#123; resolve(body); &#125;); &#125;);&#125;async function main() &#123; var data = await getJSON(); console.log(data); // NOT undefined!&#125;main(); 它们看上去和Generators很像。我（作者）强烈推荐使用 async await 来替代Generators + Promises的写法。这里是个很好的学习资源，让我们学习和使用这项ES7中的新功能。 (回到目录)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue检测变化的问题]]></title>
      <url>%2F2018%2F06%2F14%2Fchange-detection-caveats-in-vue%2F</url>
      <content type="text"><![CDATA[受现代js的限制(以及废弃的 Object.observe ),Vue不能检测到对象属性的添加或删除。实例在初始化的时候执行getter/setter的转化，属性必须在 data 对象，vue才能转化和使它响应。栗子：123456789var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应式的vm.b=2// `vm.b` 不是响应式的 Vue不允许在已经创建的实例上动态添加跟级响应式属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单校验之novalidate]]></title>
      <url>%2F2018%2F06%2F06%2Fhtml-novalidate-attribute%2F</url>
      <content type="text"><![CDATA[用django写后台项目，表单使用form，在模板中这样渲染:123456789101112131415161718192021&lt;form method="post" novalidate action="&#123;% url 'users:login' %&#125;"&gt; &#123;% csrf_token %&#125; &#123;% if form.non_field_errors %&#125; &lt;div class="error-msg"&gt; &#123;% for error in form.non_field_errors %&#125; &#123;&#123; error &#125;&#125; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125; &#123;% for field in form.visible_fields %&#125; &lt;div class="form-group&#123;% if field.errors %&#125; has-error&#123;% endif %&#125;"&gt; &lt;label&gt;&#123;&#123;field.label&#125;&#125;&lt;/label&gt; &#123;&#123; field &#125;&#125; &#123;% if field.help_text %&#125; &lt;span class="help-block"&gt;&#123;&#123; field.help_text|safe &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &#123;% for error in field.errors %&#125; &lt;span class="error-msg"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class="form-group"&gt; &lt;button type="submit" class="btn-submit"&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 因为账号和密码等等字段都是必填的,有required属性，自带的提示根据浏览器和语言都会不一样。这不是我想要的效果。 作为一个前端工程师，在后端小朋友的提示下，给表单加了novalidate属性，来去除默认的提示。然后再自己写error-msg样式。有点忧伤参考阅读： [表单数据校验](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Forms/Data_form_validation ） novalidate 表单新属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在网站中使用微软雅黑字体是否构成侵权]]></title>
      <url>%2F2018%2F06%2F04%2F%E5%9C%A8%E7%BD%91%E7%AB%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BE%AE%E8%BD%AF%E9%9B%85%E9%BB%91%E5%AD%97%E4%BD%93%E6%98%AF%E5%90%A6%E6%9E%84%E6%88%90%E4%BE%B5%E6%9D%83%2F</url>
      <content type="text"><![CDATA[早起搬砖，就看到前端群有个小伙伴在说公司被发了侵权警告书了，因为他们用了微软雅黑的字体。 我们公司的设计师也很喜欢用微软雅黑，回想自己做的项目，基本都是用这个字体，当即吓了一跳。 立刻开始Google。 找到了这篇文章,做了详细的描述。 总结如下： 我们可以将字体用在个人或商业的工作站上，但不允许将字体安装在服务器上，不能使用 css 的 @font-face 调用，字体文件不能被修改或者作为软件的一部分进行分发。这些都需要获得相应授权。在商业网站的图片上使用微软雅黑字体属于侵权行为。 我们在css中使用 {font-family:microsoft yahei} 是在合法的使用范围内。 通过css3的 @font-face 引入web字体是有风险的，尤其是对于商业性的网站。对于个人站点，想使用合法授权的web字体，可以访问： http://webfonts.fonts.com/ https://typekit.com/ http://www.google.com/webfonts 不必担心在css中使用字体名称，因为它仅仅调用了终端用户自身系统中存在的字体，不需要任何额外的许可。 you actually do not need a license to include the font name in your CSS, because it is only calling on the system font already existing in the end user’s computer, which does not need any extra license. 我自己的想法：平时设计师给的图文结合的设计稿，最好切图的时候只切css实现不了的图片，文字自己用html、css来写。这样既方便用户复制粘贴，又不会用侵权的风险。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018年6月计划]]></title>
      <url>%2F2018%2F06%2F01%2F2018%E5%B9%B46%E6%9C%88%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[career: 学习vue.js，并做一个项目； english: 扇贝继续打卡，保持20分钟每天; health: 每周锻炼三次，每次30分钟以上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端踩坑之滚动穿透]]></title>
      <url>%2F2018%2F05%2F25%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%2F</url>
      <content type="text"><![CDATA[问题描述#用了日期控件(https://github.com/foxrunsoftware/DatePicker),每次控件打开，滚动选择日期，页面主体的滚动条也还能滚动。（安卓正常，只有ios和windows chrome） 解决办法#日期控件源码修改： touchmove 事件中调用 preventDefault,将 EventTarget 从 body 改为日期控件的dom。 每次日期控件显示的时候 body:{overlow:hidden} ,隐藏的时候 body:{overflow:auto} 因为我的日期控件就在页面顶部，所以不需要记录页面的滚动位置。这样设置之后，ios和windows chrome都能够正常工作了。 bug fixed！ 网上的比较全面的解决办法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动开发之rem]]></title>
      <url>%2F2018%2F05%2F25%2F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B9%8Brem%2F</url>
      <content type="text"><![CDATA[第一次在移动端使用rem，看到设计稿尺寸一脸懵逼。尺寸宽度为1080。网上看了一堆资料，然后我直接设置了 html{font-size:20px;}，跟着感觉写了一通。最后测试的时候，样式惨不忍睹。经过公司jojo女神的点拨，重写了一遍样式。总的来说，移动端使用rem分为三步走: 设置base，一般来说为设计稿都尺寸/10；我这里设置为108. 设置html的fontSize。 12var doc_wid = document.body.clientWidth/10;document.getElementsByTagName("html")[0].style.fontSize=doc_wid+"px"; 尺寸计算：设计稿上面的实际尺寸rem/base比如header在设计稿为142px，那么就设置为 .header{height:142rem/$base} (scss的写法)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端踩坑之z-index与fixed]]></title>
      <url>%2F2018%2F05%2F25%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B8%A9%E5%9D%91%E4%B9%8Bz-index%E4%B8%8Efixed%2F</url>
      <content type="text"><![CDATA[问题描述#下拉列表z-index设置为10000,当显示的时候，应该是完全遮盖住主页面。但是在ios safari中，下拉列表向上拉的时候，会漏出定位为fixed的footer。 解决办法#在网上找了很多css的办法，都试过了，然而没有效果。后面在朋友的提示下，灵机一动，只需要写2行js代码即可。当下拉列表显示的时候,footer 隐藏。下拉列表隐藏的时候,footer显示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gulp-beginner-guide]]></title>
      <url>%2F2018%2F04%2F25%2Fgulp-beginner-guide%2F</url>
      <content type="text"><![CDATA[开始写gulp任务#写gulp任务的基本语法123gulp.task('task-name',function()&#123; //do sth here&#125;); 一般的gulp任务包含2个gulp方法，和不同的Gulp插件。一个真正的任务看起来像这样:12345gulp.task('task-name',function()&#123; return gulp.src('source-files') //get source files with gulp.src .pipe(someGulpPlugin()) //send it through a gulp plugin .pipe(gulp.dest('destination'))//output the file in the destination folder&#125;) 一般真正的任务需要2个额外的方法 — gulp.src 和 gulp.test。gulp.src告诉Gulp任务处理什么文件，gulp.dest告诉Gulp，当任务完成时候，输出的文件放哪里。 用gulp预处理(preprocessing)#使用gulp-sass插件可以将sass编译为css。先安装。1npm install gulp-sass --save-dev 从node_modules文件夹require gulp-sass，才能使用。123var gulp = require('gulp');// Requires the gulp-sass pluginvar sass = require('gulp-sass'); 用sass()方法使用gulp-sass。12345gulp.task('sass',function()&#123; return gulp.src('source-files') .pipe(sass()) //using gulp-sass .pipe(gulp.dest('destination'))&#125;); 我们需要给sass任务一个源文件和目标文件。在app/scss文件夹创建一个styles.scss。这个文件会被gulp.src添加到sass任务。12345gulp.task('sass',function()&#123; return gulp.src('app/scss/styles.scss') .pipe(sass()) .pipe(gulp.dest('app/css'))&#125;) 在命令行运行 gulp sass，可以看见在app/css下创建了一个styles.css。Gulp-sass使用LibSass将Sass编译成CSS。比基于ruby的方法快。 Glob in Node#Globs是匹配模式，允许你添加多个文件到gulp.src。有点像正则表达式，但只是针对文件路径。 当你使用glob，电脑会为这个模式检查文件名和路径。如果模式存在，文件就匹配上了。大部分的Gulp工作流只需要4种不同的globbing patterns: *.scss : *就是通配符，匹配当前目录下的任何模式。在这种情况下，我们匹配根目录下任意以 .scss 结尾的文件。 **/*.scss : 这是一个更极端的版本。匹配根目录下或者任意子目录下的 .scss 结尾的文件。 !not-me.scss : “!”表示Gulp需要从匹配中排除该模式。如果你不需要匹配的模式中的某一个文件，这很有用。这个例子中，not-me.scss 会从匹配中移除。 *.+(scss|sass) : 加号和括号允许Gulp匹配多个模式。不同的模式用pipe | 分隔开。这个例子,Gulp会匹配根目录下任意以 .scss 和 .sass 结尾的文件。 知道了golbbing,可以将原来的 app/scss/styles.scss 替换为 scss/**/*.scss 模式。这样就可以匹配任意在根目录下或者子目录下文件扩展名为 .scss 的文件了。12345gulp.task('sass',function()&#123; return gulp.src('app/scss/**/*.scss') .pipe(sass()) .pipe(gulp.dest('app/css'))&#125;); 任意在app/scss目录下的sass文件，会被自动添加到这个任务。现在，我们只用一个命令就可以将所有的sass文件编译成css。可是，每次想要把sass编译为css都要手动运行一遍 gulp sass ，这样太麻烦了。 幸运的是，每当文件发生变化，Gulp可以自动运行 sass 任务，如果这个文件被一个叫做’watching’的进程。 Watching Sass files for changes(监视sass文件的改变)#Gulp提供了一个 watch 方法看一个文件是否保存。 watch 方法的语法如下：12// Gulp watch syntaxgulp.watch('files-to-watch',['task', 'to', 'run']); 想要监视所有Sass文件并在每次一个Sass 文件保存的时候运行 sass 任务，只需要将 files-to-watch 换成 app/scss/**/*.scss ，把 [&#39;tasks&#39;, &#39;to&#39;, &#39;run&#39;] 换成 [&#39;sass&#39;] 。1gulp.watch('app/scss/**/*.scss',['sass']); 然而大多数时候，我们需要一次监视多种类型的文件。我们可以将多个监视任务组合成一个 watch 任务：1234gulp.task('watch',function()&#123; gulp.watch('app/scss/**/*.scss',['sass']) // other watchers&#125;) 可以运行 gulp watch 立刻运行监视任务。每次保存一个 .scss 文件，都会运行 sass 任务。 Live-reloading with Browser Sync#先安装：1npm install browser-sync --save-dev 注意安装的时候没有 gulp- 前缀。这是因为Gulp和Browser Sync一起工作，所以不需要使用插件。使用前需要require:1var browserSync = require('browser-sync').create(); 告诉 watch 任务，必须在 browserSync 完成之后才能运行。我们可以给 watch 任务添加一个参数来达到这个目的:1gulp.task('watch',['arrays', 'of', 'tasks', 'to', 'complete', 'before', 'watch'],function()&#123;&#125;) 比如：1234gulp.task('watch',['browserSync'],function()&#123; gulp.task('app/scss/**/*.scss',['scss']); // other watchers&#125;) 保证 sass 任务在 watch 之前运行，这样，无论什么时候运行gulp命令css都是最新的。1234gulp.task('watch',['browserSync','sass'],function()&#123; gulp.watch('app/scss/**/*.scss',['scss']); // other watchers&#125;); 现在在命令行运行 gulp watch ，gulp会同时开启 sass 和 browserSync 任务。当这两个任务都完成了， watch 才开始运行。 同时，指向 app/index.html 的浏览器窗口会弹出。如果修改 styles.scss 文件， 浏览器会自动重载。当html和js文件保存的时候，也重载。123456gulp.task('watch',['browserSync', 'sass'],function()&#123; gulp.watch('app/scss/**/*.scss',['sass']); // reload the browser whenever HTML or JS files change gulp.watch('app/*.html',browserSync.reload); gulp.watch('app/js/**/*.js',browserSync.reload);&#125;); 目前为止，做成了3件事情： 生成开发服务器 使用Sass预处理程序 每当文件发生改变，重载浏览器。 接下来优化资源，先从css和js文件开始。 优化CSS和JS文件#优化css和js的时候，开发者需要做2件事情：minification and concatenation。开发者经常遇到的问题是不能按照正确的顺序来连接这些文件。比如：123456&lt;body&gt; &lt;!-- stuff --&gt; &lt;script src"js/lib/a-xxx.js"&gt;&lt;/script&gt; &lt;script src"js/lib/b-xxx.js"&gt;&lt;/script&gt; &lt;script src"js/main.js"&gt;&lt;/script&gt;&lt;/body&gt; 这些文件不在同一个目录下。很难用传统的插件比如gulp-concatenate串联。很幸运，现在有一个插件，叫做gulp-useref能够解决这个问题。Gulp-useref将任意数量的css和js文件并为一个文件。语法如下：123&lt;!-- build:&lt;type&gt; &lt;path&gt; --&gt;... HTML Markup, list of script / link tags.&lt;!-- endbuild --&gt; &lt;type&gt; 可以是 js , css , 或者 remove 。最好是把type设置为试图串联的文件类型。如果把 type 设置为 remove ，Gulp会删除整段代码，不会生成文件。&lt;path&gt; 只得是生成文件的目标路径。我们想要js文件到 js 文件夹，名字为 main.min.js ，标记可以这样写:12345&lt;!-- build:js js/main.min.js --&gt;&lt;script src"js/lib/a-xxx.js"&gt;&lt;/script&gt;&lt;script src"js/lib/b-xxx.js"&gt;&lt;/script&gt;&lt;script src"js/main.js"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 现在来配置gulp-useref。先安装，再在gulpfile中require。1npm install gulp-useref --save-dev 1var useref=require('gulp-useref'); 设置 useref 任务：12345gulp.task('useref',function()&#123; return gulp.src('app/*html') .pipe(useref()) .pipe(gulp.dest('dist'))&#125;) 运行useref任务，Gulp会把这三个文件串联为一个，放到 dist/js/main.min.js 。现在文件还没有压缩。使用gulp-uglify插件压缩js文件，还需要gulp-if保证只压缩js。1npm install gulp-uglify --save-dev 1234567891011// other requires...var uglify=require('gulp-uglify');var gulpIf=require('gulp-if');gulp.task('useref',function()&#123; return gulp.src('app/*.html') .pipe(useref()) // minifies only if it's a javascript file .pipe(gulpIf('*.js',uglify())) .pipe(gulp.dest('dist'))&#125;); 现在每次运行 useref ，都会自动压缩js。可以用同样的方法串联css文件。1234&lt;!-- build:css css/style.min.css --&gt;&lt;link ref="stylesheet" href="css/styles.css"&gt;&lt;link ref="stylesheet" href="css/another-styles.css"&gt;&lt;!-- end build --&gt; 用gulp-cssnano插件压缩css文件：1npm install gulp-cssnano --save-dev 12345678var cssno=require('gulp-cssnano');gulp.task('useref',function()&#123; return gulp.src('app/*.html') .pipe(useref()) .pipe(gulpIf('*.js',uglify())) .pipe(gulpIf('*.css',cssnano())) .pipe(gulp.dest('dest'))&#125;); 现在每次运行 useref 就优化css和js文件。接下来，我们优化图片。 优化图片#使用gulp-imagemin优化图片。1npm install gulp-imagemin --save-dev 1var imagemin = require('gulp-imagemin'); 可以用gulp-imagemin压缩png,jpg,gif甚至是svg文件。12345gulp.task('images',function()&#123; return gulp.src('app/images/**/*.+(png|jpg|gif|svg)') .pipe(imagemin()) .pipe(gulp.dest('dist/images'))&#125;); 不同的文件类型优化得不同，所以可能需要给不同的文件类型配置不同的优化选项。比如：12345678gulp.task('images',function()&#123; return gulp.src('app/images/**/*.+(png|jpg|jpeg|gif|svg') pipe(imagemin(&#123; // setting interlaced to true interlaced:true &#125;)) .pipe(gulp.dest('dist/images'))&#125;); 优化图片很慢，没有必要每次都优化。用gulp-cache来达到这个目的：1npm install gulp-cache --save-dev 12345678910var cache=require('gulp-cache');gulp.task('images',function()&#123; return gulp.src('app/images/**/*.+(png|jpg|jpeg|gif|svg)') // caching images that ran through imagemin .pipe(cache(imagemin(&#123; interlaced:true &#125;))) .pipe(gulp.dest('dist/images'))&#125;); 基本搞定。还有一个需要到’dist’文件夹的东西：fonts。 复制字体到dist文件夹#字体已经优化了。我们不需要再做什么。用gulp复制文件：1234gulp.task('fonts',function()&#123; return gulp.src('app/fonts/**/*') .pipe(gulp.dest('dist/fonts'))&#125;) 现在每次运行 gulp fonts 都会将字体从app文件夹复制到dist文件夹。 现在已经有6个不同任务了。每个任务都单独地在命令行运行，这样有点繁琐。 自动清除生成到文件#确保不用到文件不会保留在我们不知道到地方。1npm install del --save-dev 1var del=require('del'); del 任务删除任意数组的node globs文件夹。123gulp.task('clean:dist',function()&#123; return del.sync('dist');&#125;) 现在每次运行 gulp clean:dist 就会删除dist文件夹。不用担心回删除 dist/images ，因为gulp-cache已经在本地系统保存了图片的缓存。要删除本地系统的缓存，可以创建一个清除缓存的任务。123gulp.task('cache:clear',function(callback)&#123; return cache.clearAll(callback)&#125;) Combing Gulp Tasks(组合gulp任务)#总结一下，目前我们做了2种不同类型gulp任务。第一种是开发过程中，把sass编译为css，监视变化，每次重载浏览器。第二中是优化过程，此时我们已经准备好了所有生产网站所需的文件。我们优化好css，js和图片，复制字体。 第一组任务用 gulp watch 命令行合为一个工作流了。123gulp.task('watch',['browserSync','sass'],function()&#123; // ...watchers&#125;) 第二组任务包含创建生产网站的任务： clean:dist , sass , useref , images , 和 fonts 。 要保证cleans在其他任务完成之前完成，我们需要一个插件Sequence。1npm install run-sequence --save-dev 语法如下：1234var runSequence=require('run-sequence');gulp.task('task-name',function(callback)&#123; runSequence('task-one','task-two','task-three',callback);&#125;); 当调用 task-name 的时候，gulp会先运行 task-one ，task-one 运行完成，gulp会自动开始运行 task-two ，task-two 完成，运行 task-three 。如果把任务放在一个数组里面，会同时运行这些任务。123gulp.task('task-name',function(callback)&#123; runSequence('task-one',['tasks','two','in','run','in','parallel'],'task-three',callback);&#125;); 这样，gulp先运行 task-one ，当第一个任务运行完成，gulp会同时运行第二个参数里面的任务。当数组里面所有的任务都运行完成，才会开始运行 task-three 。现在可以创建一个任务，保证 dist:clean 先运行，然后再运行其他的任务。123456gulp.task('build',function(callback)&#123; runSequence('clean:dist', ['sass','useref','images','fonts'], callback )&#125;) 为了保证一致性，第一组任务我们也可以创建顺序。12345gulp.task('default',function(callback)&#123; runSequence(['sass','browserSync','watch'], callback )&#125;) 用 default ，你只需要键入 gulp 在命令行。 [原文链接]: (https://css-tricks.com/gulp-for-beginners/ )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http & web servers unit 2 lesson 2 what about ".encode()"?]]></title>
      <url>%2F2017%2F12%2F28%2Fhttp-web-servers-unit-2-lesson-2-what-about-encode%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Http & Web Servers Unit 2 Lesson 1 Python's 'http.server']]></title>
      <url>%2F2017%2F12%2F21%2Fhttp-web-servers-unit-2-lesson-1-Python-s-http-server%2F</url>
      <content type="text"><![CDATA[Python’s http.server#上一节课，我们使用Python的 http.server 模块内置的示例服务器。但这个示例服务器也就那样 - 只是证明了模块的能力。除了提供一个目录下的静态文件，你还能用HTTP做好多其他的事情。在本节课，你会用 http.server 创建不同的网络服务，并同时学习更多关于HTTP的知识。你还会使用另一个模块, requests ，写代码充当一个HTTP的客户端。 这些模块是用面向对象编程语言Python写的。你应该已经熟悉创建类实例，定义子类和定义类的方法。如果你需要复习面向对象操作的Python语法，你可以浏览Python类教程 。 在本节课的练习中，你将写代码运行在自己的电脑上。起始代码即上节课下载的，应该在 course-ud303 目录下。用你最喜欢的文本编辑器开始练习吧！ Servers and handlers#使用 http.server 的网络服务器由两部分组成：HTTPServer类和请求处理器类。第一部分，HTTPServer 类，和所有的网络服务一样，是内建在模块内的。它知道如何监听端口，接收来自客户端的请求。每当它接收到一个请求时，它就将请求交到第二部分 - 请求处理器 - 每个网络服务器的请求处理器都不一样。 为了运行一个网络服务，你的Python代码需要做到下面的几点： 引入 http.server 模块，至少是你需要的那一部分。 创建一个 http.server.BaseHTTPRequestHandler 子类。这就是你的处理器类。 在处理器类为每一个你想要处理的 HTTP verb 定义方法。(在这个课程中，我们唯一见到的 HTTP verb就是 GET ，但之后我们会见到更多其他的。) GET 请求的方法必须叫做 do_GET。 在方法内，调用处理器类的内置方法读取HTTP请求并写响应。 创建一个 http.server.HTTPServer 的实例，将你的处理器类和服务器信息给它 - 特别是你的端口号。 调取这个 HTTPServer 实例的 run_forever 方法。 一旦你调取 HTTPServer 实例的 run_forever 方法，它就会永远运行，除非停止。就像上一节课那样，如果你的Python服务器在运行中，你想要让它停止运行，就在它运行的终端键入 Ctrl-C。（有时候你需要键入两到三次。） Exercise: The hello server#我们来快速看一个例子。从你的终端，进入到你之前下载的 course-ud303 目录下，在 Lesson-2 子目录下，你可以看到 0_HelloServer 子目录。里面有一个Python程序叫做 HelloServer.py 。在你到文本编辑器打开它看看。然后在你的终端运行这个程序: python3 HelloServer.py 。它什么都不会做，直到你通过浏览器访问 http://localhost:8000/ 。 A tour of the hello server#在文本编辑器打开 HelloServer.py ，我们来一行一行地看看这段代码的每一个部分。 1from http.server import HTTPServer, BaseHTTPRequestHandler http.server模块里面包含很多部分内容。现在，这个程序只需要其中两个部分。我们现在使用 import 的 from 语法，这样我们就不用在代码里一遍又一遍打 http.server 。 12class HelloHandler(BaseHTTPRequestHandler): def do_GET(self): 这就是处理器类。从在 http.server 中定义的 BaseHTTPRequestHandler 父类继承下来。我已经定义了一个方法，do_Get ，用来处理 HTTP GET 请求。当这个网络服务器接收到一个 GET 请求，它就会调取这个方法响应。 在之前的课程中我们了解到，服务器在一个 HTTP 响应中需要发送3样东西：一个状态码，一些头信息，和一个响应主体。处理器的父类对处理这些事情都有方法。在 do_Get 中，我只需要依次调取它们即可。 12# First, send a 200 OK responseself.send_response(200) 服务器需要要做的就是发送一个 200 OK 状态码; send_response 方法做这个。我不需要告知它200意味着OK；父类已经知道这个了。 123# Then send headers.self.send_header('Content-type','text/plain;charset=utf-8')self.end_headers() 接下来服务器需要做的就是发送 HTTP 头。 父类提供 send_header 和 end_headers 方法来做这些。目前，我只让服务器发送了一个单行的头 - Content-type 头告知客户端响应主体会是 UTF-8 编码的纯文本。 12# Now,write the response body.self.wfile.write("Hello, Http!\n".encode()) do_GET 方法的最后一部分写响应主体。 父类给了我们一个叫做 self.wfile 的变量来发送响应。 wfile 代表着 writeable file 。Python和很多其他的编程语言一样，将打开文件和网络连接类比起来：它们都是你能读取的数据。有些文件对象是只读的；有些是只写的；有些是既能读也能写的。 self.wfile 代表着服务器到客户端的连接；如名字所示，它是只读的。它的 write 方法将任意的二进制数据写到发送到客户端的响应中。 .encode() 是干嘛的？之后我们再看。现在让我们看看剩下的其他代码。 1234if __name__ == '__main__': server_address = ('', 8000) # Serve on all addresses, port 8000. httpd = HTTPServer(server_address, HelloHandler) httpd.serve_forever() 如果我们将该模块当作Python程序运行，这段代码才会运行。如果只是引入，则不会运行。HTTPServer 构造函数需要知道它监听的是哪个地址和端口；当我调用 server_address 的时候，将地址和端口作为元组传入。我也给了它 HelloHandler 类，它会用这个来处理来自客户端的请求。 在文件的最后，我在 HTTPServer 调取了 server_forever ，让它开始处理HTTP请求。服务器开始运行了。 End of the tour#用Python写最基本的HTTP服务器就是这些内容了。但是这个hello server不怎么有趣。甚至做的还没有示例服务器多。不管你查询什么，它都只会说hello。 余下的课程，我们会建造不只是说hello的服务器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP & Web Servers Unit 1 Lesson 7 Prepare for the next class]]></title>
      <url>%2F2017%2F12%2F21%2Fhttp-web-servers-unti-1-lesson-7%2F</url>
      <content type="text"><![CDATA[这篇博文是记录学习udacity的课程http &amp; web servers的第七篇。 Congratulations!#你可以使用各种有趣的客户端和服务器在HTTP进行会话。幸运的是，在真实世界创建网络应用时，Python 让这变得容易多了。接下来的课程，我们会写Python代码来发送和接收请求，而不是自己手动操作。 Downloadable exercises#接下来的两节课，我们会做一些练习，涉及到在你的电脑上运行Python服务器。为这些练习做准备，我们需要下载开始的代码。打开终端，运行如下命令： 123git clone https://github.com/udacity/course-ud303cd course-ud303git remote remove origin 在自己的电脑上看看 course-ud303 目录的子目录以及里面的文件。 查看原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP & Web Servers Unit 1 Lesson 6 HTTP responses]]></title>
      <url>%2F2017%2F12%2F20%2Fhttp-web-servers-unti-1-lesson-6-http-responses%2F</url>
      <content type="text"><![CDATA[HTTP responses#在上一节课的练习中,当输入 Host:localhost 按下两次enter键，服务器发回一堆的文本。这就是一个HTTP响应(HTTP response）。当你的浏览器向服务器请求一个页面，一张图片，或者任何东西，都会发生请求和响应的交换。 其他方法测试一下。使用 ncat 连接到 google.com 80端口，发送一个请求，路径为 / ，在google.com 主机上： 12GET / HTTP/1.1Host: google.com 确保发送的是 Host: google.com ，不要加上 www 在这里。它们本质上是不同的主机名，我们想要看看它们的区别。按下2次enter键！ (我测试了一下，返回的是”Operation time out.”) HTTP 响应由三部分组成：状态行，一些头，和响应主体。(the status line,some headers,and a response body) 状态行(status line)是服务器发回的第一行文本。头(headers)是在空白行之前的其他行。响应主体(response body)是剩下的部分 - 在示例中，即这些HTML。 Status line#在之前的示例服务器中，状态行为 HTTP/1.0 200 OK 。在Google的例子中，状态行为 HTTP/1.1 301 Moved Permanently 。状态行告知客户端，服务器是否明白它的请求，服务器是否有它请求的资源，接下来如何继续。它也告知客户端服务器使用的是哪种HTTP方言。 数字200和301是HTTP 状态码(status code)。状态码分为几十种。状态码的第一个数字表明请求的大概结果。为了简写，网页开发人员将所有 2 开头的状态码写为 2xx ，’x’代表任意的数字。 1xx - Informational. 该请求正在进行中，或者还有另外的步骤。 2xx - Success! 请求成功。服务器正在发送客户端请求的数据。 3xx - Redirection. 服务器告知客户端它应该重定向到其他的URI。这些头通常还包含一个指明更新的URI地址(Location)的头。不同的状态码告知客户端重定向是永久的还是临时的。 4xx - Client error. 服务器不明白客户端的请求，或不能满足它。不同的状态码告知客户端它是否是一个坏的URI，或者权限问题，或其他的问题。 5xx - Server error. 服务器端发生错误。 可在该维基百科页或者这个HTTP规范页查看更多关于HTTP状态码的资料。 Headers#一个HTTP响应可以包含多个头(headers)。每个头都以一个关键字开始一行，比如 Location 或者 Content-type ，接着是一个冒号和值。头相当于是响应的元数据。浏览器或者其他客户端不会展示它们，与之相替的是，它们会告诉客户端各种关于响应的信息。 WEB的很多很多特性都是通过头实现的。例如，cookies 是一个WEB特性，它让服务器将数据保存到浏览器上，如让用户保持登录状态。服务器发送 Set-Cookie 头设置一个cookie。浏览器在之后的请求中会通过一个 Cookie 头将cookie数据发送回服务器。 Content-type 头表明服务器发送的是何种数据，包含一般的类别和具体的格式。例如，一个PNG格式图片的 Content-type 为 image/png 。如果内容是文本，包括HTML，服务器也会告知文本是由哪种方式编码的。UTF-8是常见的选择，也是Python文本的默认编码方式。 头经常会包含更多关于响应主体的元数据。例如，示例服务器和Google都发送了一个 Content-Length 头，这告知客户端响应主体的长度(以bytes计算)。当服务器发送了这条信息，客户端可以在读取第一个响应后重新使用该连接发送另一个请求。浏览器利用这个获取多条数据（比如网页上的很多图片），而不需要重新连接到服务器。 Response body#头部信息以一个空白行结尾。空白行之后的所有内容都是响应主体(response body)。如果该请求是成功的(比如一个 200 OK 状态)，响应主体就是客户端请求的任何资源的副本，如网页、图片或者任何其他的数据。 但如果发生错误，响应主体就是错误信息。如果你请求一个不存在的资源，你会得到 404 Not Found 错误，实际的错误显示在响应主体中。 Exercise: Be a web server!#使用 ncat -l 9999 监听9999端口，使用浏览器连接到它 http://localhost:9999/ 。在终端能看到什么？ 我的终端出现的是这些信息: 123456789GET / HTTP/1.1Host: localhost:9999Connection: keep-aliveUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36Upgrade-Insecure-Requests: 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8DNT: 1Accept-Encoding: gzip, deflate, brAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 接下来，发送一个HTTP响应给你的浏览器，在浏览器发送给你的头下面键入以下内容: 12HTTP/1.1 307 Temporary RedirectLocation: https://www.eff.org/ 最后，按两次enter键发送一个空白行，表明头的结束。 浏览器会打开eff的主页。 再试一次，运行 ncat -l 9999 充当服务器，让你的浏览器连接到此，但这次，不要发送307重定向，发送 200 OK 和一段文本。 12345HTTP/1.1 200 OKContent-type: text/plainContent-length: 50Hello, browser! I am a real HTTP server, honestly! (记住头和主体之间的空白行！) 浏览器会展示你发送的这条信息”Hello, browser! I am a real HTTP server, honestly!” 查看原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP & Web Servers Unit 1 Lesson 5 HTTP GET requests]]></title>
      <url>%2F2017%2F12%2F20%2Fhttp-web-servers-unti-1-lesson-5-http-get-requests%2F</url>
      <content type="text"><![CDATA[HTTP GET requests#查看下示例服务器运行的终端服务器日志。当你向示例服务器请求一个页面，日志会出现这样一条记录：1127.0.0.1 - - [03/Oct/2016 15:45:50] &quot;GET /readme.png HTTP/1.1&quot; 200 - 查看日期和时间之后的部分, “GET /readme.pg HTTP/1.1” ，这就是浏览器发送给服务器的请求行的文本。该条日志记录告诉你它收到了一个请求，照字面意义，GET /readme.pg HTTP/1.1 。 这条请求有三个部分。 GET 是使用的方法(method)或HTTP动词(HTTP verb)，这表明发出的是什么样的请求。当客户端想要服务器发送某个资源，比如一个网页或者图片，就使用 GET 方式。我们会在之后查看当客户端想要做其他事情，比如提交表单或对某个资源作出修改，使用的其他的方式。 /readme.png 是请求的资源的路径。注意：客户端在此没有发送该资源的完整的URI。它并没有说 https://localhost:8000/readme.png 。它只是发送路径。 最后， HTTP/1.1 是该请求的协议。这么多年过去，HTTP如何工作发生了一些改变。客户端必须告知服务器它们说的是HTTP的哪一种方言。现在，HTTP/1.1是最常见的版本。 Exercise: Send a request by hand#可以使用 ncat 连接到示例服务器，手动发送一个HTTP请求。开启一个终端，运行示例服务器，python3 -m http.server 8000。使用 ncat 127.0.0.1 8000 将终端连接到示例服务器。键入下面两行:12GET / HTTP/1.1Host: localhost 按两次enter键，服务器的响应会马上显示在你的终端。根据你终端的尺寸大小，网络服务器的文件数量，你可能会需要向上滚动才能看到响应的开始。 查看原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP & Web Servers Unit 1 Lesson 4 Hostnames and ports]]></title>
      <url>%2F2017%2F12%2F19%2Fhttp-web-servers-unti-1-lesson-4-hostnames-and-ports%2F</url>
      <content type="text"><![CDATA[Hostnames#一个完整的 HTTP 或 HTTPS URI包含网络服务器的主机名，比如 www.udacity.com 或者 www.un.int 或者 www.cheeseboardcollective.coop 。URI的主机名也可以是一个IP地址。如果在浏览器键入：http://216.58.194.174/ 会访问Google。 为什么叫做主机名？在网络术语中，一个主机就是在网络上的一台能够托管服务的电脑。 互联网通过IP地址区分不同的电脑；互联网上每一次的网络通讯，都标记了发送和接收方的IP地址。为了连接到一个网络服务器，比如 www.udacity.com , 客户端需要将其主机名转换为IP地址。我们的操作系统网络配置使用域名服务(Domain Name Service) - 由互联网服务提供商 (isp) 和其他网络用户维护的一组服务器 - 查找主机名，获取IP地址。 在终端，我们可以使用 host 程序在DNS中来查找主机名。在终端中输入 host www.google.com ，输出如下：www.google.com has address 66.220.152.28www.google.com has IPv6 address 2404:6800:4008:800::2004 在终端中输入 host www.baidu.com ，输出如下：www.baidu.com is an alias for www.a.shifen.com.www.a.shifen.com has address 61.135.169.121www.a.shifen.com has address 61.135.169.125 在浏览器地址栏输入百度的IP地址： 61.135.169.125 或 61.135.169.121 会访问百度的主页。 有一些系统没有 host 命令，但有一个类似的命令叫做 nslookup 。这个命令也会展示你给出的主机名的IP地址，它还会显示给出答案的DNS服务器的IP地址。 我的测试结果：june:~ june$ nslookup www.google.comServer: 192.168.1.150Address: 192.168.1.150#53 Non-authoritative answer:Name: www.google.comAddress: 31.13.71.23 june:~ june$ nslookup www.baidu.comServer: 192.168.1.150Address: 192.168.1.150#53 Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 61.135.169.125Name: www.a.shifen.comAddress: 61.135.169.121 localhost 的 IPv4 地址是什么？用 host 或者 nslookup 在终端测试一下。答案：127.0.0.1 有两种不同的IP地址：老的 IPv4 和 新的 IPv6 。如果你看到一个地址如 127.0.0.1 或者 216.58.194.164 ，这些是IPv4地址。IPv6地址要长一些，如 2607:f8b0:4005:804::2004 ，但是这些地址可以缩写。 Localhost#IPv4地址 127.0.01 和IPv6地址 ::1 是特定的地址，指这台电脑自己。主机名 localhost 指代的就是这些特定的地址。 当运行示例服务器的时候，会打印出一条消息，正在监听 0.0.0.0 端口。这不是一个常规的IP地址。相反，它是一个特定的编码，指代”这台电脑上的所有IPv4地址”，包含 localhost ，也包含你电脑的常规IP地址。 Ports#当你告知浏览器连接到示例服务器，你在浏览器输入URI http://localhost:8000 。这个URI有一个端口号：8000 。但你在自然环境中看到的大部分网络地址上是没有端口号的。这是因为客户端通常可以通过URI方案知道端口号。 例如，HTTP URIs意味着端口号为 80 ，而HTTPS URIs意味着端口号为 443 。你的python示例服务器运行在8000端口。因为这不是默认的端口号，所以我们需要在URI中指明其端口号。 到底什么是端口号？ 为了了解这个，我们需要先知道互联网是如何工作的。电脑发送和接收的所有的网络通信 - 从网络请求到登录回话，再到文件共享等 - 消息都被拆分为数据包。每个包都有发送方和接收方电脑的IP地址。也有发送方和接收方的端口号(某些低级的数据包，比如ping例外)。IP地址区分电脑；端口号区分这些电脑上的程序。 我们说服务器“监听”某个端口，比如 80 或者 8000，“监听”意味着服务器开启了，它告知操作系统它想要在某个特定端口接收客户端的连接。当一个客户端，比如一个网络浏览器，“连接”到这个端口，发送一个请求，操作系统知道将该请求转发到服务器监听的端口。 为什么我们的示例服务器使用 8000 端口而非 80 端口？由于历史原因，操作系统只允许管理员(或者根)账号监听1024之下的端口。这对于生产网络服务器没有问题，但对于学习不太方便。 想了解更多关于地址，端口和互联网的运作，可查看该课程 Web 开发者的网络入门 查看原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP & Web Servers Unit 1 Lesson 3 Parts of a URI]]></title>
      <url>%2F2017%2F12%2F18%2Fhttp-web-servers-unti-1-lesson-3-parts-of-uri%2F</url>
      <content type="text"><![CDATA[Parts of a URI#网络地址也叫做URI，统一资源标识符。从网络用户的角度来看，URI就是一段文本你键入到浏览器，告知浏览器你想访问哪个页面。从网络开发者的角度来看，URI要稍微复杂点. 你或许见过术语URL,或者统一资源定位符。两者非常接近。具体来说，url是网络资源的URI。a URL is a URI for a resource on the network.因为URI稍微更精确一点，我们在课程中会使用该术语。不必太担心二者之间的区别。 一个URI即一个资源的名字 - 就比如眼前这个页面，一个维基百科的文章，一个数据资源比如Google地图的api。URI由几个部分组成，每个部分都有自己对语法。有些部分是可选的，这就是为什么不同服务的URI不同于彼此。 这是一个URI的例子：https://en.wikipedia.org/wiki/Fish 这个URI有三个可见的部分，由一些标点符号分开： https is the scheme;(方案) en.wikipedia.org is the hostname;(主机名) and /wiki/Fish is the path;(路径) Scheme#URI的第一部分是方案(scheme),告诉客户端如何获取资源。常见的URI方案有：http,https,file。文件URI方案告诉客户端在本地文件系统获取文件。http和https URI指向网络服务器提供的资源。 http和https URIs看起来基本一样。区别在于，当一个客户端通过https URI去获取一个资源，会使用加密的连接。加密的网络连接最初用于保护密码和信用卡交易，但现在，很多的网站会使用它们保护用户的隐私。 还有很多其他的URI方案。可在http://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml 查看。 Hostname#在http URI中，方案之后就是主机名(hostname)：比如www.udacity.com或者localhost。这告知客户端连接到哪个服务器。 我们经常看到网络地址写得和主机名一样。但在html代码中，我们不能这样写&lt;a href=&quot;www.google.com&quot;&gt;this&lt;/a&gt;就连接到Google。主机名只能出现在它支持的URI方案之后，比如 http 或者 https 。在这些URIs之后，必须还有 :// 分开方案和主机名。不是所有的URIs都有主机名。比如 mailto URI只需要一个邮箱地址: malito:spamexample.net 就是一个符合语法规范的 mailto URI。这也稍微更多地展现了URI中的标点符号用法: : 在方案之后，// 在主机名之前。mailto 没有主机名部分，所以没有 // 部分。 Path#在http URI(和很多其他),下一个出现的就是路径，指明了服务器上的一个特定的资源。一个服务器可以有很多资源在上面 - 比如不提的网页，视频或者api。路径告知服务器客户端要查找的是哪一个资源。 在之前的示例服务器上，你看到的路径与你的文件系统上的文件相对应。真实世界中，URI路径并不一定与特定的文件名相同。比如，如果你Google搜索，你会看到一个类似/search?q=ponies 的URI路径。这并不意味着Google服务器上有一个名为 /search?q=ponies 的文件。服务器解析路径，确定发送什么资源。在搜索请求的例子中，服务器会发送回之前可能从未存在过的搜索结果页面。 如果写一个没有路径的URI，比如http://udacity.com，浏览器会自动填充默认路径，即一个斜杠。http://udacity.com和http://udacity.com/ (单斜杆结尾) 是一样的。 一个斜杠的路径也叫做根(root)。示例服务器的根URI - http://localhost:8000/ -就是你电脑的整个文件系统的根，即网络服务器提供的资源的根。示例服务器不会让浏览器获取不是它运行的目录下的文件。 Relative URI references#查看示例服务器根页面的html源码。看到其中的一个&lt;a&gt;标签链接到一个文件。比如：&lt;a href=&quot;cliffsofinsanity.png&quot;&gt;cliffsofinsanity.png&lt;/a&gt;像这样的URIs没有方案或者主机名，只有一个路径。这就是相对URI引用(relative URI reference)。这是相对于上下文 - 具体来说，即它出现的页面。这个URI并不包含主机名或它所在服务器的端口，但浏览器能够从上下文弄清楚。如果你点击其中的一个链接，浏览器根据上下文知道它需要从原始页面的同一个服务器去拿资源。 Other URI parts#一个URI中可能出现其他的部分。看看下面2个维基百科URIs的区别： https://en.wikipedia.org/wiki/Oxygen https://en.wikipedia.org/wiki/Oxygen#Discovery在浏览器中输入上面的链接，会访问维基百科网络服务器上的同一个页面。但第二个会展示页面滚动到氧气的发现这部分内容。# 符号之后的URI部分叫做 fragment (片段)。 浏览器不会将这部分发送到网络服务器。它只是让一个链接指向某个资源的一个具体的部分；在HTML页面中，它会通过 id 链接到某个元素。 相比之下，看看google搜索的URI: https://www.google.com/search?q=fish?q=fish 是URI的查询部分。这部分会发送到服务器。 URI可能还有其他的部分，可以在下面的维基百科页面查看更多详情： https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax 查看原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP & Web Servers Unit 1 Lesson 2 Your first web server]]></title>
      <url>%2F2017%2F12%2F18%2Fhttp-web-servers-unti-1-lesson-2-your-first-web-server%2F</url>
      <content type="text"><![CDATA[练习：运行你的第一个网络服务器#服务器只需要做一件事：处理收到的请求。Python的http.server模块可以你的电脑上运行一个内置的网络服务器。 开一个终端，cd到一个含有一些文件的目录，可以是文本文件，html文件或者图片，然后在终端运行：python3 -m http.server 8000。 浏览器键入：http://localhost:8000/ 。这个示例服务器是一个真正的网络服务器。如果该本地网络还有其他的电脑，你可以使用其他电脑获取该服务器上的文件。当你在浏览器键入localhost:8000，你的浏览器会向你正在运行的python程序发送http请求。这个程序会返回一段数据，浏览器会展示给你。 Note:如果刚才的目录下，你有一个文件叫做index.html，你会看到index.html的内容，而不是目录下的文件列表。将index.html移动到其他地方，你看到的又是目录下的文件列表。 什么是服务器？#A server is just a program that accepts connections from other programs on the network. 当你开始一个服务器程序，它等着客户端连接到它-就像刚才的示例服务器等着浏览器向它请求一个页面一样。当连接来了，服务器运行一段代码 - 比如运行一个函数 - 来处理每一个到来的连接。就像是打电话：通过这个渠道，服务器和客户端可以互聊。网络客户端通过连接发送请求，服务器发送响应回来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP & Web Servers Unit 1 Lesson 1 Introduction]]></title>
      <url>%2F2017%2F12%2F18%2Fhttp-web-servers-unti-1-lesson-1-introduction%2F</url>
      <content type="text"><![CDATA[准备工作# 安装python3 安装git 安装Nmap 在两个终端测试ncat程序 安装Nmap# Windows: 下载运行 https://nmap.org/dist/nmap-7.30-setup.exe Mac (with Homebrew):在终端运行 brew install nmap Mac (without Homebrew): 下载安装 https://nmap.org/dist/nmap-7.30.dmg Debian/Ubuntu/Mint: 终端运行 sudo apt-get install nmap 检查ncat是否正确安装运行，开2个终端，其中一个运行ncat -l 9999,另一个运行ncat localhost 9999.然后在其中一个终端输入一些内容，按enter键，应该可以在另一个终端看到输入的内容。其中一个ncat程序在这里充当了一个简单的网络服务器的角色，另一个充当客户端角色。 Note:如果发生错误如“Address already in use”,表示你电脑中已经有其他程序在使用9999端口。你可以换个端口使用。注意客户端和服务器需要使用同一个端口。在终端输入Control-C退出ncat程序。如果先输入的是服务器端，客户端会自动退出。因为服务器关闭会自动中断连接。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP-Caching]]></title>
      <url>%2F2017%2F12%2F13%2FHTTP-Caching%2F</url>
      <content type="text"><![CDATA[Validating cached responses with ETags# The server uses the ETag HTTP header to communicate a validation token. The validation token enables efficient resource update checks:no data transferred if the resource has not changed.Ensure that the server is providing the necessary ETag tokens. Check your server documentation for the necessary configuration flags. Cache-Control# Each resource can define its caching policy via the Cache-Control HTTP header. Cache-Control directives control who can cache the response, under which conditions, and for how long. “no-cache” and “no-store”#“no-cache” indicates that the returned response can’t be used to satisfy a subsequent request to the same URL without first checking with the server if the response has changed. As a result, if a proper validation token (ETag) is present, no-cache incurs a roundtrip to validate the cached response, but can eliminate the download if the resource has not changed. By contrast, “no-store” is much simpler. It simply disallows the browser and all intermediate caches from storing any version of the returned response—for example, one containing private personal or banking data. Every time the user requests this asset, a request is sent to the server and a full response is downloaded. “public” vs. “private”#If the response is marked as “public”, then it can be cached, even if it has HTTP authentication associated with it, and even when the response status code isn’t normally cacheable. Most of the time, “public” isn’t necessary, because explicit caching information (like “max-age”) indicates that the response is cacheable anyway. By contrast, the browser can cache “private” responses. However, these responses are typically intended for a single user, so an intermediate cache is not allowed to cache them. For example, a user’s browser can cache an HTML page with private user information, but a CDN can’t cache the page. “max-age”#This directive specifies the maximum time in seconds that the fetched response is allowed to be reused from the time of the request. For example, “max-age=60” indicates that the response can be cached and reused for the next 60 seconds. Define optimal Cache-Control policy#https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/images/http-cache-decision-tree.png Invalidating and updating cached responses# Locally cached responses are used until the resource “expires.” Embedding a file content fingerprint in the URL enables you force the client to update a new version of the response. Each application needs to define its own cache hierarchy for optimal performance. All HTTP requests that the browser makes are first routed to the browser cache to check whether there is a valid cached response that can be used to fulfill the request. If there’s a match, the response is read from the cache, which eliminates both the network latency and the data costs that the transfer incurs. How do you get the best of both worlds: client-side caching and quick updates? You change the URL of the resource and force the user to download the new response whenever its content changes. Typically, you do this by embedding a fingerprint of the file, or a version number, in its filename—for example, style.x234dff.css. Caching checklist# Use consistent URLs:if you serve the same content on different URLs, then that content will be fetched and stored multiple times. Ensure that the server provides a validation token (ETag): validation tokens eliminate the need to transfer the same bytes when a resource has not changed on the server. Identify which resources can be cached by intermediaries: those with responses that are identical for all users are great candidates to be cached by a CDN and other intermediaries. Determine the optimal cache lifetime for each resource:different resources may have different freshness requirements. Audit and determine the appropriate max-age for each one. Determine the best cache hierarchy for your site:the combination of resource URLs with content fingerprints and short or no-cache lifetimes for HTML documents allows you to control how quickly the client picks up updates. Minimize churn: some resources are updated more frequently than others. If there is a particular part of a resource (for example, a JavaScript function or a set of CSS styles) that is often updated, consider delivering that code as a separate file. Doing so allows the remainder of the content (for example, library code that doesn’t change very often), to be fetched from cache and minimizes the amount of downloaded content whenever an update is fetched.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web-font-optimization]]></title>
      <url>%2F2017%2F12%2F12%2Fweb-font-optimization%2F</url>
      <content type="text"><![CDATA[Anatomy of a webfont# Unicode fonts can contain thousands of glyphs. There are four font formats:WOFF2,WOFF,EOT,and TTF. Some font formates require the use of compression. Webfont formats:# EOT:IE only TTF:partial IE support WOFF:widest support but not available in some older browsers WOFF2:in progress for many browsers There is no single format that works in all browsers,which means that we need to deliver multiple fomats to provide consistent experience: Serve WOFF 2.0 variant to browsers that support it. Serve WOFF variant to the majority of browsers. Serve TTF variant to old Android (below 4.4) browsers. Serve EOT variant to old IE (below IE9) browsers. Reducing font size with compression#A font is a collection of glyphs, each of which is a set of paths describing the letter form. The individual glyphs are different, but they contain a lot of similar information that can be compressed with GZIP or a compatible compressor: EOT and TTF formats are not compressed by default. Ensure that your servers are configured to apply GZIP compression when delivering these formats. WOFF has built-in compression. Ensure that your WOFF compressor is using optimal compression settings. WOFF2 uses custom preprocessing and compression algorithms to deliver ~30% file-size reduction over other formats. Note: Consider using Zopfli compression for the EOT, TTF, and WOFF formats. Zopfli is a zlib compatible compressor that delivers ~5% file-size reduction over gzip. Define a font family with @font-face# Use the format() hint to specify multiple font formats. Subset large Unicode fonts to improve performance. Use Unicode-range subsetting and provide a manual subsetting fallback for older browsers. Reduce the number of stylistic font variants to improve the page- and text-rendering performance. The browser requests the HTML document. The browser begins parsing the HTML response and constructing the DOM. The browser discovers CSS, JS, and other resources and dispatches requests. The browser constructs the CSSOM after all of the CSS content is received and combines it with the DOM tree to construct the render tree. Font requests are dispatched after the render tree indicates which font variants are needed to render the specified text on the page. The browser performs layout and paints content to the screen. If the font is not yet available, the browser may not render any text pixels. After the font is available, the browser paints the text pixels. The “race” between the first paint of page content, which can be done shortly after the render tree is built, and the request for the font resource is what creates the “blank text problem” where the browser might render page layout but omits any text.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[automate-image-optimization]]></title>
      <url>%2F2017%2F12%2F04%2Fautomate-image-optimization%2F</url>
      <content type="text"><![CDATA[https://github.com/imagemin/imageminhttps://github.com/jcupitt/libvips compress images tools: ImageOptim MozJPEG Progressive JPEG pngquant SVGO Instead of crazy huge animated GIFs, deliver H.264 videos (or WebM for Chrome, Firefox and Opera)! gif: https://github.com/pornel/giflossy image optimisation Choose the right format Size approriately Adapt intelligently Compress carefully Prioritize critical images Lazy-load the rest Take care with tools Tools and libraries like ImageMagick, libjpeg, jpegtran, jpeg-recompress and imagemin support exporting Progressive JPEGs. SVG can be powerful for icons, offering a way to represent visualizations as a sprite without the quirky workarounds needed for icon fonts. It has more granular CSS styling control than icon fonts (SVG stroke properties), better positioning control (no need to hack around pseudo-elements and CSS display) and SVGs are much more accessible. Tools like svg-sprite and IcoMoon can automate combining SVGs into sprites which can be used via a CSS Sprite, Symbol Sprite or Stacked Sprite. Una Kravetz has a practical write-up on how to use gulp-svg-sprite for an SVG sprite workflow worth checking out. Sara Soudein also covers making the transition from icon fonts to SVG on her blog. Always comprese from the original image. Recompressing images has consequences. When editing your source files,store them in a lossless format like PNG or TIFF,so you preserve as much as quality as you can. Resizing and decoding images are expensive operations for a browser on average mobile hardware.Serve the smallest images for your target screen sizes and resolutions, taking advantage of srcset and sizes. Omitting the width or height attributes on an image can also negatively impact performance. Without them, a browser assigns a smaller placeholder region for the image until sufficient bytes have arrived for it to know the correct dimensions. At that point, the document layout must be updated in what can be a costly step called reflow.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[notes of loading performance]]></title>
      <url>%2F2017%2F11%2F30%2Fnotes-of-loading-performance%2F</url>
      <content type="text"><![CDATA[Understanding Low Bandwith and High Latency# introduce tools to emulate network Use timeouts to handle intermittent connectivity Optimizing Content Efficiency#Eliminating Unnecessary Downloads#TL;DR - Inventory your own assets and third-party assests on your pages. - Measure the performance of each asset:its value and its technical performance - Determine if the resources are providing sufficient value Eliminate unnecessary resources from application. - you&apos;ve always included resource x on your pages,but doest the cost of downloading and displaying it offset the value it delivers to the user? Can you measure and prove its value? - Does the resource(especially if it&apos;s a third-party resource) deliver consistent performance?Is that resource in the critical path,or need to be?If the rescource is in the critical path,could it be a single point of failure for the site?That is,if the resource is unavailable,does it affect performance and the user experience of your page? - Does this resource need or have an SLA?Does this resource follow performance best practices:compression,caching,and so on. Too often,pages contain resources that are unnecessary,or worse,that hinder page performance without delivering much value to the visitor or to the site they&apos;re hosted on.This applies equally to first-party and third-party resources and widgets. Optimizing Encoding and Transfer Size of Text-Based Assets#1. Data compression 101 TL;DR: - Compression is the process of encoding information using fewer bits. - Eliminating unnecessary data always yields the best results. - There are many different compression techniques and algorithms. - You will need a varity of techniques to achieve the best compression. 2. Minification:preprocessing &amp; context-specific optimizations TL;DR: - Content-specific optimizations can significantly reduce the size of delivered resources. - Content-specific optimizations are best applied as part of your build/release cycle. 3. Text compression with GZIP TL;DR: - GZIP performs best on text-based assets:CSS,JavaScript,HTML - All modern browsers support GZIP compression and will automatically request it. - Your server must be configured to enable GZIP compression. - Some CDNs require special care to ensure that GZIP is enabled. - Apply content-specific optimizations first: CSS, JS, and HTML minifiers. - Apply GZIP to compress the minified output. Enabling GZIP is one of the simplest and highest-payoff optimizations to implement, and yet, many people don&apos;t implement it. Most web servers compress content on your behalf, and you just need to verify that the server is correctly configured to compress all the content types that benefit from GZIP compression. A quick and simple way to see GZIP in action is to open Chrome DevTools and inspect the “Size / Content” column in the Network panel: “Size” indicates the transfer size of the asset, and “Content” the uncompressed size of the asset. Image Optimization#Eliminating and replacing images#TL;DR: - Eliminate unnecessary image resources - Leverage CSS3 effects where possible - Use web fonts instead of encoding text in images Vector vs. Raster images#TL;DR： - Vector images are ideal for iamges that consists of geometric shapes - Vector images are zoom and resolution-independent - Raster images shoud be used of complex scenes with lots of irregular shapes and details Implications of high-resolution screens#TL;DR - High resolution screens have multiple device pixels per css pixel - High resolution images require significantly higher number of pixels and bytes - Image optimization techniques are the same regardless of resolution prefer vector images wherever possible. if a raster image is required,deliver and optimize multiple variants of each imagewith of help of srcset and picture. Optimizing vector images#TL;DR - SVG is an XML-based image format - SVG files shoud be minified to reduce their size (tool:svgo) - SVG files to compressed with GZIP Optimizing raster images#TL;DR - A raster images is a grid of pixels - Each pixel encodes color and transparency information - Image compressors use a variety of techniques to reduce the number of required bits per pixel to reduce file size of the image Lossless vs loosy image compression#TL;DR - Due to how our eyes work,images are great candidates for lossy compression - Image optimization is a function of lossy and lossless compression - Differences in image formats are due to the difference in how and which lossy and lossless algorithms are used to optimize the images - There is no single best format or &quot;quality setting&quot; for all images:each combination of particular compressor and image contents produce a unique output Selecting the right image format#TL;DR - Start by selecting the right universal format:gif,png,jepg - Experiment and select the best settings for each format:quality,palette size,etc - Consider adding WebP and JPEG XR assets for modern clients 1. Do you need animation? If so, GIF is the only universal choice 1. Do you need to preserve fine detail with highest resolution? Use PNG. 1. Are you optimizing a photo,screenshot,or a similar image asset? Use JPEG. WebP and JPEG XR : - Some CDNS provide image optimization as a service,including JPEG XR and WebP delivery. - Some open-source tools(for example,PageSpeed for Apache or Nginx) automate the optimization,conversation,and serving of approriate assets. - You can add additional application logic to detect the client,check which formats they support,and serve the best availlable image format. Tools and parameter turning#- gifsicle:create and optimize GIF images - jpegtran:optimize JPEG images - optipng:lossless PNG optimization - pngquant:lossy PNG optimization Deliver scaled image assets#TL;DR - Deliver scaled assets is one of the simplest and most effective optimizations - Pay close attention to large assets as they result in high overhead - Reduce the number of unnecessary pixels by scaling your images to their display size Image optimization boils down to two criteria: optimizing the number of bytes used to encode each image pixel, and optimizing the total number of pixels: the filesize of the image is simply the total number of pixels times the number of bytes used to encode each pixel. Nothing more, nothing less. As a result, one of the simplest and most effective image optimization techniques is to ensure that we are not shipping any more pixels than needed to display the asset at its intended size in the browser. Sounds simple, right? Unfortunately, most pages fail this test for many of their image assets: typically, they ship larger assets and rely on the browser to rescale them - which also consumes extra CPU resources - and display them at a lower resolution. **you should ensure that the number of unnecessary pixels is minimal, and that your large assets in particular are delivered as close as possible to their display size.** Image optimization checklist#- __Prefer vector formats__ - __Minify and compress SVG assets__ - __Pick best raster image format__ - __Experiment with optimal quality settings for raster formats__ - __Remove unnecessary image metadata__ - __Serve scaled images__ - __Automate__:invest into automated tools and infrastructure that will ensure that all of your image assets are always optimized reference:https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[performance notes]]></title>
      <url>%2F2017%2F11%2F30%2Fperformance-notes%2F</url>
      <content type="text"><![CDATA[Mearsure Performance with Rail Model#response,animation,idle,loadTL;DR - Focus on the user;the goal isn&apos;t to make your site perform fast on any specific device, its to ultimately make users happy. - Respond to users immediately;acknowledge user input in under 100ms. - When animating or scrolling,produce a frame in under 10ms. - Maxmize main thread idle time. - Keep users engaged;deliver interactive content in under 1000ms. Focus on the user#Response:respond in under 100ms#Animation:produce a frame in 10ms#Idle:maximize idle time#Use idle time to complete deferred work. For example, keep pre-load data to aminimum so that your app loads fast, and use idle time to load remainning data/ Deferrend work should be grouped into blocks of about 50ms. Should a user begin interacting, then the highest priority is to respond to that. To allow for &amp;lt;100ms response,the app must yield control back to main thread every &amp;lt;50ms,such that can execute its pixel pipeline,react to user input,and so on. Working in 500ms blocks allows the task to finish while still ensuring instant response. Load:deliver content under 100ms#Load your site in under 1 second. Focus on optimizing the critical rendering path to unblock rendering. You don&apos;t have to load everything in under 1 second to produce the perception of a complete load.Enable progressive rendering and do some work in the background.Defer non-essential loads to periods of idle time. reference:https://developers.google.com/web/fundamentals/performance/rail]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css布局学习]]></title>
      <url>%2F2017%2F11%2F21%2Fcss%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[max-width 使用max-width替代width可以使浏览器更好地处理小窗口的情况。所有主流浏览器斗支持max-width，包括ie7+. 1234#main&#123; max-wdith:600px; margin:0 auto;&#125; box-sizing 传统的盒子模型不直接，所以新增了box-sizing的css属性。当你设置元素的CSS box-sizing:border-box;时，此原属的内边距和边框不再会增加它的宽度。 不过 box-sizing 是个很新的属性，目前需要使用 -webkit- 和 -moz- 前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+的。 position static 默认值。任意CSS position:static;的元素表示不会被特殊定位。 relative fixed 一个固定定位CSS position:fixed;元素会相对于视窗来定位，这意味着即使页面滚动，它还是会停留在相同的位置。和CSS position:relative;一样，top\right\bottom\left属性都可用。 脱离文档流。 移动浏览器对fixed支持很差。 absolute absolute 是最棘手的position值。 absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是 static 的元素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试浮动崩溃]]></title>
      <url>%2F2017%2F10%2F25%2Ffloat-test%2F</url>
      <content type="text"><![CDATA[While floats do provide quite a bit of fire power, they do come with a few of their own problems. The most popular problem involves a parent element that contains numerous floated elements. Content on the page will respect the size and placement of the floated children element, but these floated elements no longer impact the outer edges of the parent container. In this event the parent element loses context of exactly what it contains and collapses, thus giving the parent element a height of 0 and ignoring various other properties. A lot of times this may go unnoticed, specifically when the parent element doesn’t have any styles tied to it and the nested elements look to have aligned correctly. Should the nested elements not line up correctly, styling errors may appear. Taking a look at the demo below, the .box-set division should have a light gray background, however the background is not seen as all of the elements nested within it are floated. Upon inspecting the .box-set division you will see it has a height of 0. reference:https://learn.shayhowe.com/advanced-html-css/detailed-css-positioning/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017/10/23 review my new year goal]]></title>
      <url>%2F2017%2F10%2F23%2F2017-10-23%2F</url>
      <content type="text"><![CDATA[回顾自己的2017目标： 学习目标# Expert knowledge of HTML5, CSS, Javascript, and W3C compliance这个目标很难衡量，但我知道我今年并没有花时间去系统全面的学习这些。完成度0%。 Knowledge of advanced CSS using a preprocessor(SCSS&amp;Gulp)会用sass了。这个目标完成度只有20%。 TypeScript (2017/1/20学习完成基本语法概念)没有在实际项目中使用，学好的语法知识现在已经全部忘记了。在练习中学习在项目中学习在实践中学习才是王道。 NodeJS完全没有花时间去学习。 PYTHON完全没有花时间在这个上面。 英语词汇量到2万，目前一万八完成了。每天20分支保持住了。健身目标# 目前体重 51.4kg，希望年底能到45kg。现在47.5kg，希望年底能达成这个目标。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[a-pixel-is-not-a-pixel]]></title>
      <url>%2F2017%2F06%2F05%2Fa-pixel-is-not-a-pixel%2F</url>
      <content type="text"><![CDATA[The tricky bits#However, there are two tricky bits: the device-width media query and the &lg;meta name=”viewport” width=”device-width” &gt;tag. Both work with device pixels, and not with CSS pixels, because they report on the context of the web page, and not on its inner CSS workings.device-width媒体查询和&lg; meta name=”viewport” width=”device-width” &gt;都是指设备像素，而不是css像素。 The media query#The device-width media query measures the width of the device in device pixels. The width media query measures the total width of the page in CSS pixels, which, for reasons I’ll explain later, is at least 980px on the iPhone.The device-width media query works as follows:1234567891011div.sidebar &#123; width: 300px;&#125;@media all and (max-device-width: 320px) &#123; // styles assigned when device width is smaller than 320px; div.sidebar &#123; width: 100px; &#125;&#125; Now the sidebar is 300 CSS pixels wide, except when the device width is 320 device pixels or less, in which case it becomes 100 CSS pixels wide.侧边栏为300 css像素宽，除非设备的宽度小于等于320,此时，侧边栏的css像素变为100px.By the way, in theory you could use a media query that queries the device screen in centimeters or inches (@media all and (max-device-width: 9cm)). Unfortunately it seems badly to outright unsupported, even by the iPhone. The problem here is that physical units such as inches are usually translated to (CSS) pixels; thus width: 1in equals 96 pixels on all browsers I tested so far (and that’s quite a few). So these media queries are unreliable.理论上说可以使用设备屏幕的厘米或者英寸来媒体查询。但是基本浏览器都不支持。 The tag#In general &lt;meta name=”viewport” content=”width=device-width” &gt; is even more useful. This tag, originally Apple-proprietary but meanwhile supported by many more mobile browsers, actually makes the layout viewport fit the device exactly.Now what is the layout viewport? It’s the area (in CSS pixels) that the browser uses to calculate the dimensions of elements with percentual width, such as div.sidebar {width: 20%}. It’s usually quite a bit larger than the device screen: 980px on the iPhone, 850px on Opera, 800 on Android, etc. If you add &lt;meta name=”viewport” content=”width=device-width” &gt;, the width of this layout viewport is constrained to the device width in device pixels; 320 of them in the iPhone’s case. So basically Google has already inserted a layer of what are apparently called dips; device-independent pixels. This layer comes between the official, reported screen size and the CSS pixels web developers work with.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git add 详解]]></title>
      <url>%2F2017%2F06%2F05%2Fgit-add%2F</url>
      <content type="text"><![CDATA[1、前言#git add命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。 2、基本#git add &lt; path &gt;表示 add to index only files created or modified and not those deleted通过git add &lt; path &gt;的形式把我们&lt; path &gt;添加到索引库中，&lt; path &gt;可以是文件也可以是目录。git不仅能判断出&lt; path &gt;中，修改（不包括已删除）的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。 3、git add -u#git add -u 表示 add to index only files modified or deleted and not those created git add -u [&lt; path &gt;]: 把&lt; path &gt;中所有tracked文件中被修改过或已删除文件的信息添加到索引库。它不会处理untracted的文件。省略&lt; path &gt;表示.,即当前目录。 4、git add -A#git add -A: [&lt; path &gt;]表示把&lt; path &gt;中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。省略&lt; path &gt;表示.,即当前目录。 5、git add -i#我们可以通过git add -i [&lt; path &gt;]命令查看&lt; path &gt;中被所有修改过或已删除文件但没有提交的文件，并通过其revert子命令可以查看&lt; path &gt;中所有untracted的文件，同时进入一个子命令系统。 5.1、revert子命令#可以通过git add -i的revert子命令（3: [r]evert）把已经添加到索引库中的文件从索引库中剔除。（3: [r]evert）表示通过3或r或revert加回车执行该命令。执行该命令后，git会例出索引库中的文件列表.然后通过数字来选择。输入”1”表示git会例出索引库中的文件列表中的第1个文件。“1-15”表示git会例出索引库中的文件列表中的第1个文件到第15个文件.回车将执行。如果我们不输入任何东西，直接回车，将结束revert子命令，返回git add -i的主命令行。 5.2、update子命令#可以通过update子命令（2: [u]pdate）把已经tracked的文件添加到索引库中。其操作和revert子命令类似。 5.3、add untracked子命令#通过add untracked子命令（4: [a]dd untracked）可以把还没被git管理的文件添加到索引库中。其操作和revert子命令类似。 5.4、diff子命令#可以通过diff子命令（6: [d]iff）可以比较索引库中文件和原版本的差异。其操作和revert子命令类似。 5.5、status子命令#status子命令(1: [s]tatus)功能上和git add -i相似 5.6、quit子命令#quit子命令（7: [q]uit）用于退出git add -i命令系统 6、帮助#我们可以通过git add -h命令来看git add命令的帮助文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设备像素、设备独立像素、css像素]]></title>
      <url>%2F2017%2F06%2F01%2Fabout-pixel%2F</url>
      <content type="text"><![CDATA[definition#设备像素:#又称物理像素（physical pixel），设备能控制显示的最小单位，我们可以把这些像素看作成显示器上一个个的点。 CSS像素#CSS像素是Web编程的概念，独立于设备的用于逻辑上衡量像素的单位，也就是说我们在做网页时用到的CSS像素单位，是抽象的，而不是实际存在的。 设备独立像素：#(也叫密度无关像素)，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。 在PC端可以通过screen.width/height属性来获取设备独立像素值，在PC端这个值把它当成我们常说的屏幕分辨率（实际上它不是，但是由于在PC端设备像素和设备独立像素数值相等，才有这么一个不准确的说法）。但你把浏览器切换到设备模式时，也就是在移动端环境下通过上面的screen.width/height获取的不是移动设备的分辨率，而是移动设备的屏宽/高（这里只是猜测），如：Iphone 5s下screen.width =320、screen.height = 568。本以为是浏览器里的设备环境没有完全模拟真实的移动设备环境，可是用真机测试时，还是出现同样的结果screen.width =320、screen.height = 568。值得注意的是：不管你手机是否切换到横屏，这两个值还是一样的。所以不管是移动端还是PC端通过screen.width/height获取的这个值是设备独立像素（CSS 像素），而不是设备的屏幕分辨率，因为设备的屏幕分辨率对于WEB开发者来说是无法通过代码来获得的，是完全透明的. 摘自：http://yunkus.com/physical-pixel-device-independent-pixels/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[devicePixelRatio]]></title>
      <url>%2F2017%2F05%2F31%2FdevicePixelRatio%2F</url>
      <content type="text"><![CDATA[definition#window.devicePixelRatio is the ratio between physical pixels and device-independent pixels (dips) on the device.window.devicePixelRatio = physical pixels / dips Dips are the abstract pixels that are used to feed information to the width/height media queries and the meta viewport device-width. relation with other properties#dips:设置页面的&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;，获取document.documentElement.clientWidth，大部分浏览器会返回viewport layout的宽度，即为dips summary# devicePixelRatio is mostly trustworthy on most browsers. On iOS devices, multiply devicePixelRatio by screen.width to get the physical pixel count. On Android and Windows Phone devices, divide screen.width by devicePixelRatio to get the dips count.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[a-bit-of-pixels]]></title>
      <url>%2F2017%2F05%2F31%2Fa-bit-of-pixels%2F</url>
      <content type="text"><![CDATA[dips:device independent pixels#当页面设置了1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 的时候，document.documentElement.clientWidth在大部分浏览器下，得到的是布局视区的宽度，等同于dips的宽度。 screen.width#对于screen.width的值： 在iOS视网膜设备上，screen.width返回dips宽。因此，在竖着显示的时候，视网膜显示屏的ipad和非视网膜显示屏的ipad返回的都是768. 在某些Android设备上，screen.width返回的是物理像素宽度 summary# devicePixelRatio在大多数浏览器是值得信赖的. 在iOS设备，screen.width乘以devicePixelRatio得到的是物理像素值。 在Android以及Windows Phone设备，screen.width除以devicePixelRatio得到的是设备独立像素(dips)值。 摘自：http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[learn-compass]]></title>
      <url>%2F2017%2F05%2F27%2Flearn-compass%2F</url>
      <content type="text"><![CDATA[It’s important to remember that long selectors incur a small rendering performance penalty that in aggregate can slow down your web page. There is no need to exactly mimic your document structure in your css. Instead nest only deep enough that the selector is unique to that part of the document. For instance, don’t use table thead tr th when a simple th selector will suffice. This might mean that you have to separate your styles into several selectors and let the document cascade work to your advantage.摘自：http://compass-style.org/help/tutorials/best_practices/ 长的选择器会影响渲染表现，累积起来会导致页面变慢。没有必要在css里效仿你的文档结构。只需要嵌套到该选择器在该部分文档唯一的就足够了。比如，当一个简单的th选择器就够了的时候，不要使用table thead tr th。这意味着你必须把样式分散在几个选择器中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[font-face]]></title>
      <url>%2F2017%2F05%2F23%2Ffont-face%2F</url>
      <content type="text"><![CDATA[昨天要改一个很简单的需求，把网站的标题改下。修改了html，发现字体很奇怪。有的是设计师给的，有的不是。 本以为需要切图，查看了源码，发现字体文件只有之前标题的那几个字。新增的字没有办法应用那个字体。 找设计师要来了他的字体文件，truetype的，解压。上传到http://transfonter.org。把自己需要的那几个字，也就是新的标题转为svg,woff,ttf,eot,woff2格式。替换掉原来的font文件即可。 12345678910@font-face &#123; font-family: "myfont"; src: url("../font/myfont.eot"); /* IE9 */ src: url("../font/myfont.eot?#iefix") format("embedded-opentype"), /* IE6-IE8 */ url("../font/myfont.woff") format("woff"), /* chrome, firefox */ url("../font/myfont.ttf") format("truetype"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url("../font/myfont.svg#myfont") format("svg"); /* iOS 4.1- */ font-style: normal; font-weight: normal;&#125; 查看为何这段代码生效：http://blog.fontspring.com/2011/02/the-new-bulletproof-font-face-syntax/1234567@font-face &#123; font-family: 'MyFontFamily'; src: url('myfont-webfont.eot?#iefix') format('embedded-opentype'), url('myfont-webfont.woff') format('woff'), url('myfont-webfont.ttf') format('truetype'), url('myfont-webfont.svg#svgFontName') format('svg'); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片文字垂直居中]]></title>
      <url>%2F2017%2F05%2F11%2Fvertical-aligin-middle%2F</url>
      <content type="text"><![CDATA[个数不定的文字内容与图片的垂直居中对齐1234&lt;div&gt;&lt;span&gt;文字们哈哈哈哈哈&lt;/span&gt;&lt;img src="/images/june.jpg"&gt;&lt;/div&gt; 12div&gt;span&#123;display:inline-block;width:210px;vertical-align:middle;&#125;div&gt;img&#123;vertical-align:middle;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[border与等高布局]]></title>
      <url>%2F2017%2F05%2F01%2Fborder-and-layout%2F</url>
      <content type="text"><![CDATA[12345678&lt;div class="box"&gt; &lt;nav class="left"&gt; &lt;h3&gt;导航1&lt;/h3&gt; &lt;/nav&gt; &lt;section&gt; &lt;div class="module"&gt;&lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 12345678.box&#123; border-left:300px solid #222;&#125;.left&#123; width:300px; margin-left:-300px; float:left;&#125; reference:http://www.imooc.com/video/13378测试了上面的代码，发现没有实现等高布局。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用border构建三角形]]></title>
      <url>%2F2017%2F05%2F01%2Fborder-and-triangle%2F</url>
      <content type="text"><![CDATA[利用border构建三角形 方案一#123456.triangle&#123; border-width:12px 20px; border-style:solid; border-color:red red transparent transparent; font-size:0;&#125; 1&lt;a href="" class="triangle"&gt;&lt;/a&gt;//要使用行内元素 方案二#1234567.triangle&#123; width:0px; height:0px; border-width:100px; border-style:solid; border-color:red transparent transparent transparent;&#125; 1&lt;div class="triangle&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用echarts画个花花绿绿的甜甜圈图]]></title>
      <url>%2F2017%2F04%2F12%2Fuse-echarts-to-draw-colorful-donut-graph%2F</url>
      <content type="text"><![CDATA[ui的设计稿有个花花绿绿的甜甜圈图。因为项目的图都是echarts画的，所以，继续玩弄echarts。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170$(function()&#123; var chart = echarts.init(document.getElementById('city_level_chart')); var labelLineStyle=&#123;color:'#94A0B6',width:3&#125;; var labelStyle=&#123; show:true, formatter:'&#123;c&#125;个&#123;a&#125;', textStyle:&#123; color:'#94A0B6', fontSize:16 &#125; &#125;; var option = &#123; color: ['#EB4C39', '#EC6A2C','#F6C94A', '#EC6A2E','RGBA(64, 146, 222, 1.00)'], silent:true, series:[ &#123; type:'pie', clockwise:false, name:'一线城市', radius:['10%','20%'], itemStyle:&#123; normal:&#123; label:labelStyle, labelLine:&#123; show:true, length:5, length2:12, labelLine:labelLineStyle &#125; &#125; &#125;, data:[ &#123; value:3, itemStyle:&#123; normal:&#123; color:'#F5A29A', label:&#123;show:false&#125;, labelLine:&#123;show:false&#125; &#125; &#125; &#125;, &#123;value:1&#125; ] &#125;, &#123; type:'pie', clockwise:false, name:'二线城市', radius:['20%','30%'], itemStyle:&#123; normal:&#123; label:labelStyle, labelLine:&#123; show:true, length:5, length2:12, labelLine:labelLineStyle &#125; &#125; &#125;, data:[ &#123; value:27, itemStyle:&#123; normal:&#123; color:'RGBA(245, 179, 145, 0.8)', label:&#123;show:false&#125;, labelLine:&#123;show:false&#125; &#125; &#125; &#125;, &#123;value:3&#125; ] &#125;, &#123; type:'pie', clockwise:false, name:'三线城市', radius:['30%','40%'], itemStyle:&#123; normal:&#123; label:labelStyle, labelLine:&#123; show:true, length:5, length2:12, labelLine:labelLineStyle &#125; &#125; &#125;, data:[ &#123; value:66, itemStyle:&#123; normal:&#123; color:'RGBA(251, 226, 160, 0.8)', label:&#123;show:false&#125;, labelLine:&#123;show:false&#125; &#125; &#125; &#125;, &#123;value:4&#125; ] &#125;, &#123; type:'pie', clockwise:false, name:'四线城市', radius:['40%','50%'], itemStyle:&#123; normal:&#123; label:labelStyle, labelLine:&#123; show:true, length:5, length2:12, labelLine:labelLineStyle &#125; &#125; &#125;, data:[ &#123; value:90, itemStyle:&#123; normal:&#123; color:'RGBA(167, 221, 197, 0.8)', label:&#123;show:false&#125;, labelLine:&#123;show:false&#125; &#125; &#125; &#125;, &#123;value:0&#125; ] &#125;, &#123; type:'pie', clockwise:false, name:'五线城市', radius:['50%','60%'], itemStyle:&#123; normal:&#123; label:labelStyle, labelLine:&#123; show:true, length:5, length2:12, labelLine:labelLineStyle &#125; &#125; &#125;, data:[ &#123; value:128, itemStyle:&#123; normal:&#123; color:'RGBA(156, 198, 238, 0.8)', label:&#123;show:false&#125;, labelLine:&#123;show:false&#125; &#125; &#125; &#125;, &#123;value:1&#125; ] &#125; ] &#125;; chart.setOption(option);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[training-record]]></title>
      <url>%2F2017%2F03%2F17%2Ftraining-record%2F</url>
      <content type="text"><![CDATA[今天公司组织了培训，大神讲了很多原理性的东西，获益匪浅。我要跟着大神好好学习。今天把homepage的布局写好了。数据也沟通得差不多了。预计下周可以出来效果了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[input的autofocus属性小坑]]></title>
      <url>%2F2017%2F03%2F14%2Fabout-autofocus-attribute-of-input%2F</url>
      <content type="text"><![CDATA[今天要修复一个小bug，当发生点击事件，会显示表单，要让表单内部的input自动获得焦点。我想当然给表单控件设置了autofocus属性，然而，没有生效。查看了下mdn的信息： autofocus HTML5This Boolean attribute lets you specify that a form control should have input focus when the page loads, unless the user overrides it (e.g. by typing in a different control). Only one form element in a document can have the autofocus attribute, which is a Boolean. It cannot be applied if the type attribute is set to hidden (that is, you cannot automatically set focus to a hidden control). Note that the focusing of the control may occur before the firing of the DOMContentLoaded event. 为何我的修改没有效果？因为我的页面列表是ajax请求数据生成的，而autofocus是在页面加载的时候就确定一个表单控件是否获取焦点。 Note that the focusing of the control may occur before the firing of the DOMContentLoaded event. 我的input标签是在页面加载完成之后才添加到dom中的;所以设置的autofocus没有生效。最后还是老老实获取表单元素，添加focus事件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用padding布局]]></title>
      <url>%2F2017%2F03%2F13%2Fpadding-and-layout%2F</url>
      <content type="text"><![CDATA[使用百分比构建固定比例布局#移动端：1:1 头图123div&#123; padding:50%;&#125; 配合margin实现等高布局#很大的margin-bottom,padding-bottom值填充缺失的空间。123456789101112131415.box&#123; overflow:hidden; resize:vertical;&#125;.child-orange,child-green&#123; margin-bottom:-600px;padding-bottom:600px;&#125;.child-orange&#123; float:left; background-color:orange;&#125;.child-green&#123; float:left; background-color:green;&#125; 两栏自适应布局#padding在容器上#12345678&lt;div class="pbox"&gt; &lt;img src="xx.jpg"&gt; text here Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt; 1234567.pbox&#123; padding-left:120px;&#125;.pbox img&#123; float:left; margin-left:-120px;&#125; padding在子元素上#123456789&lt;div&gt; &lt;img src="xx.jpg"&gt; &lt;div class="auto"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/div&gt;&lt;/div&gt; 1234img&#123;float:left;&#125;.auto&#123; padding-left:120px;&#125; 内容参考来自张鑫旭的慕课网视频：(http://www.imooc.com/video/12600).]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用padding绘制图形]]></title>
      <url>%2F2017%2F03%2F13%2Fuse-padding-to-draw-graph%2F</url>
      <content type="text"><![CDATA[借助padding实现三道杠#1&lt;div class="tri-line"&gt;&lt;/div&gt; 12345678.tri-line&#123; width:150px; height:30px; border-top:30px solid; boder-bottom:30px solid; background-color:currentColor; background-clip:content-box;&#125; 借助padding实现白眼效果#1&lt;div class="eye"&gt;&lt;/div&gt; 123456789.eye&#123; width:150px; height:150px; padding:10px; border:10px solid; border-radius:50%; background-color:currentColor; background-clip:content-box;&#125; 参考:css padding与图形绘制–张鑫旭]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单元素内置padding值]]></title>
      <url>%2F2017%2F03%2F13%2Fpadding-of-form-elements%2F</url>
      <content type="text"><![CDATA[结论# 所有浏览器的input／textarea都有内置padding值。 所有浏览器的button按钮都有内置padding值。 部分浏览器select下拉有padding值，比如firefox。ie8+可以设置padding值。 所有浏览器的radio/checkbox没有padding值。 button元素的padding很奇葩。。。 button元素的padding# chrome ok firefox ok ieie7 下文字越多，padding越大，设置button{overflow:visible;}可以解决杀掉多余的padding值 padding高度计算不兼容 12345button&#123; line-height:20px; padding:10px; border:none;&#125; ie7 45px ?ie8+ 40px okfirefox 42px ?chrome 40px ok button兼容性不好，大大降低了平时开发中的使用率。平时多用a标签来代替，当需要原生的button按钮时候，建议方案： 12&lt;button id="btn"&gt;&lt;/button&gt;&lt;label for="btn"&gt;button&lt;/label&gt; 12345label&#123; display:inline-block; line-height:20px; padding:10px;&#125; 另外需要设置button的不可访问，非display:none;visible:hidden;而是绝对定位到屏幕之外或者设置z-index为-1,让button元素隐藏在背景色下。 兼容ie7， ie8+， firefox, chrome. 参考：标签元素的内置padding–css深入理解之padding-by张鑫旭]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css简单代码实现正方形]]></title>
      <url>%2F2017%2F03%2F12%2Fcss%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[简单代码实现正方形：1div&#123;padding: 50%&#125; 应用案例：很多移动端app头图1:1，屏幕尺寸大小不固定，让所有的屏幕大小下都是正方形。123456&lt;div class="container"&gt; &lt;div class="example"&gt; &lt;h2&gt;hello&lt;/h2&gt; &lt;h4&gt;other info&lt;/h4&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314.container&#123; padding:50%; background:url(exp.jpg); background-size:100%; position:relative;&#125;.example&#123; position:absolute; top:0; right:0; bottom:0; left:0;&#125; 内容参考来自张鑫旭的慕课网视频：(http://www.imooc.com/video/12598 ).]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何避免table自动换行]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dtable%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[HTML的表格渲染很特殊，当单元格的内容过长，就会自动换行，导致表格的显示很凌乱。只要添加2行css代码就可以解决这个问题。 对table元素，应用css代码： 1234/*让文本在同一行继续*/table&#123; white-space:nowrap&#125; 给table的父元素添加样式： 123.table-wraper&#123; overflow:auto; &#125; 不过这样生成的滚动条很随性。如果追求美观，需要再调整一下滚动条的样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[周总结]]></title>
      <url>%2F2017%2F02%2F17%2F%E5%91%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[本周马不停蹄地写项目。在应用中发现自己的不足，还有很多需要学习的。css首当其冲。平时写得太少，导致用的时候踩了很多坑。比如一个sticky footer,看似简单，实现起来发现毛病真多。学习编程，真的是需要多多地敲代码，多多地应用，多多地测试。我很享受现在的工作。实现一个功能或者效果带来的巨大成就感，还有，找到解决办法的酸爽，推动着我继续前行。编程，真的是一项很有趣的手艺。我愿意为此投入时间与精力，而不只是当作谋生的手段。 现在工作中的大神，我真的很羡慕，我也想要成为那样的人。一个有专业技能的妇女。 打算有时间把https://css-tricks.com/这个网站的代码都实现下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[养成良好的工作习惯]]></title>
      <url>%2F2017%2F02%2F08%2F%E5%85%BB%E6%88%90%E8%89%AF%E5%A5%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E4%B9%A0%E6%83%AF%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[看不懂代码的忧伤]]></title>
      <url>%2F2017%2F02%2F04%2F%E7%9C%8B%E4%B8%8D%E6%87%82%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BF%A7%E4%BC%A4%2F</url>
      <content type="text"><![CDATA[DJANGO的user模块，我搞了很久，还是不太懂。用大神写的代码，models里面定义的类似懂非懂。下午用sqlite命令，把用户表里面的数据展现出来了，能直观地看到用户信息了，然并卵，还是不会继续写。这个逻辑有点绕。 至少学了会儿sqlite的命令。。。忧伤的一个下午。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一月总结]]></title>
      <url>%2F2017%2F02%2F03%2F%E2%80%9CJanuarySummary%E2%80%9D%2F</url>
      <content type="text"><![CDATA[一月健身总时间:1159分钟。主要是健步走。平均每天运动38分钟。然而没有减肥下来。扇贝英语听力单词打开23天。主要是上下班的车上背的。阅读完成《Thinking in CSS》、《Thinking in HTML》、《Thinking in Javascript》、《Flourish》。学习完成typescript的基本语法。 减肥之路道阻且长。健步走运动强度不大，效果不明显。需要加大运动强度了。买了跳绳，计划每天跳2000下。从二月开始。 原来体重51.4kg，现在51.2kg，姑且认为减肥有一丢丢的效果吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reverse text]]></title>
      <url>%2F2017%2F01%2F23%2Freverse-text%2F</url>
      <content type="text"><![CDATA[实现文字从右到左。123&lt;div dir="rtl"&gt; right to left text&lt;/div&gt; 1234selector&#123; unicode-bidi:bidi-override; direction:rtl;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用最少的css代码做star rating]]></title>
      <url>%2F2017%2F01%2F23%2Fstar-rating-with-css%2F</url>
      <content type="text"><![CDATA[参考链接 first-step: 直接用unicode 标记星星(编码utf-8,so easy)#123&lt;div class="rating"&gt;&lt;span&gt;☆&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;span&gt;☆&lt;/span&gt;&lt;/div&gt; second-step: 给:hover添加伪元素，使得空心star变为实心#123456.rating &gt; span:hover:before&#123; /*content属性与:before以及:after伪元素使用，插入生成内容。*/ /*该属性用于定义元素之前或之后放置的生成内容。默认地，这往往是行内内容，不过该内容创建的框类型可以用属性 display 控制。*/ content:"\2605"; position:absolute;&#125; third-step: 解决选择相邻同级元素的问题#css 不能直接选择之前的同级元素，可以选择之后的同级元素。所以，这里我们把字符的顺序更改了，就可以使用同级元素了，选取on hover 元素之前的所有star了。12345678910.rating &#123; unicode-bidi: bidi-override; direction: rtl;&#125;.rating &gt; span:hover:before,.rating &gt; span:hover ~ span:before &#123; content: "\2605"; position: absolute; color: gold;&#125; summary#一般网站的打分功能需要与后台交互。这个只是一个纯样式的，没有数据交互。可以使用radio 表单元素设计可以真正交互的star rating。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017 new year goal]]></title>
      <url>%2F2017%2F01%2F23%2F2017-new-year-plan%2F</url>
      <content type="text"><![CDATA[学习目标# Expert knowledge of HTML5, CSS, Javascript, and W3C compliance Knowledge of advanced CSS using a preprocessor(SCSS&amp;Gulp) TypeScript (2017/1/20学习完成基本语法概念) NodeJS PYTHON 英语词汇量到2万，目前一万八 健身目标# 目前体重 51.4kg，希望年底能到45kg。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test markdown]]></title>
      <url>%2F2017%2F01%2F23%2Ftext-markdown%2F</url>
      <content type="text"><![CDATA[just test markdown syntax 123var a=0;var b=10;console.log(a+b); frontend# css html javascript backend# python sql pg]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[猴年倒数第二个工作日]]></title>
      <url>%2F2017%2F01%2F23%2F%E7%8C%B4%E5%B9%B4%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%B7%A5%E4%BD%9C%E6%97%A5%2F</url>
      <content type="text"><![CDATA[Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sequi necessitatibus, quo ad quia cumque optio commodi facilis vero atque dolores at repellat, laborum officia iste omnis nam vitae! A, dolorum!Perferendis suscipit repudiandae reiciendis libero fugit voluptatem excepturi at maiores amet cumque dolorem, ex, totam, molestias nesciunt quibusdam nisi labore facere nulla soluta consectetur impedit in. Ipsum qui sint esse.Debitis blanditiis animi earum aliquid est facere similique minus quo saepe error pariatur perferendis deleniti necessitatibus sit, laboriosam, non, odit porro sapiente delectus quod laudantium obcaecati doloribus? Enim, a, saepe!Quidem accusantium eaque ipsa, fugiat ea iusto error harum perferendis. Soluta culpa a sequi incidunt libero ut, cum laboriosam blanditiis dolores accusantium numquam necessitatibus dolor voluptatibus, officiis ab repellendus quo.Vitae non deserunt mollitia doloremque consequuntur, inventore distinctio voluptates voluptas perferendis, minima iure incidunt accusantium eveniet est consectetur dignissimos? Ratione eligendi, nihil ullam, placeat esse amet deleniti. Optio qui, nihil?Fuga eos odit consequuntur asperiores sed architecto. Eaque ut hic qui, iure officiis non voluptate nesciunt cupiditate libero omnis ullam aperiam corporis, tempora sapiente est ducimus, provident placeat totam deleniti!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F23%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new "My New Post" More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
